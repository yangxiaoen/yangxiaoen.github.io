<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>杨小恩同学的博客</title>
  
  <subtitle>一个专注技术学习的小白</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-02-05T06:44:19.385Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>杨小恩</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>AndriodStudio安装与配置</title>
    <link href="http://yoursite.com/2020/02/05/AndriodStudio%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2020/02/05/AndriodStudio安装与配置/</id>
    <published>2020-02-05T02:55:45.967Z</published>
    <updated>2020-02-05T06:44:19.385Z</updated>
    
    <content type="html"><![CDATA[<h5 id="步骤一-系统要求"><a href="#步骤一-系统要求" class="headerlink" title="步骤一 系统要求"></a>步骤一 系统要求</h5><p>Windows 10 ；<br>Java JDK5 及以后版本；</p><h5 id="步骤二-安装-Android-Studio"><a href="#步骤二-安装-Android-Studio" class="headerlink" title="步骤二 安装 Android Studio"></a>步骤二 安装 Android Studio</h5><h6 id="概况"><a href="#概况" class="headerlink" title="概况"></a>概况</h6><p>Android Studio 是开发 Android 应用程序的官方 IDE，基于 Intellij IDEA。你可以从<a href="http://www.android-studio.org/index.php" target="_blank" rel="noopener">官网Android Studio</a>下载下载最新版本的 Android Studio。</p><h6 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h6><p>下载<br><img src="https://s2.ax1x.com/2020/02/05/1rJbI1.png" alt="1rJbI1.png"></p><p>确保在安装 Android Studio 之前，已经安装好 Java JDK。<br><img src="https://s2.ax1x.com/2020/02/05/1rJ7Z9.png" alt="1rJ7Z9.png"><br><img src="https://s2.ax1x.com/2020/02/05/1rJoqJ.png" alt="1rJoqJ.png"><br><img src="https://s2.ax1x.com/2020/02/05/1rJ5MF.png" alt="1rJ5MF.png"><br><img src="https://s2.ax1x.com/2020/02/05/1rJIr4.png" alt="1rJIr4.png"><br><img src="https://s2.ax1x.com/2020/02/05/1rJHaR.png" alt="1rJHaR.png"></p><ul><li><p>首次安装的情况下，选择不导入之前版本的配置。<br><img src="https://s2.ax1x.com/2020/02/05/1rJXRK.png" alt="1rJXRK.png"></p></li><li><p>在启动的时候会出现下图，点击Don’t send</p></li></ul><p><img src="https://s2.ax1x.com/2020/02/05/1rJjxO.png" alt="1rJjxO.png"></p><ul><li>出现向导界面，点击next<br><img src="https://s2.ax1x.com/2020/02/05/1rJxMD.png" alt="1rJxMD.png"></li><li>选择安装类型，这里选择Standard（使用默认配置，比较方便）<br><img src="https://s2.ax1x.com/2020/02/05/1rJzse.png" alt="1rJzse.png"></li><li>选择UI主题，这里根据个人习惯选择就好<br><img src="https://s2.ax1x.com/2020/02/05/1rY9Zd.png" alt="1rY9Zd.png"></li><li>如果前面选择Standard，则出现下图，SDK默认安装在C盘，点击Finish。如希望更改路径，在前面选择Custom。<br><img src="https://s2.ax1x.com/2020/02/05/1rYCdA.png" alt="1rYCdA.png"></li><li>开始下载SDK组件<br><img src="https://s2.ax1x.com/2020/02/05/1rYPII.png" alt="1rYPII.png"></li><li>至此安装完成，可以创建自己的第一个Android项目了。<br><img src="https://s2.ax1x.com/2020/02/05/1rYFit.png" alt="1rYFit.png"></li></ul><h6 id="创建Hello-Word项目"><a href="#创建Hello-Word项目" class="headerlink" title="创建Hello Word项目"></a>创建Hello Word项目</h6><p><img src="https://s2.ax1x.com/2020/02/05/1rYkJP.png" alt="1rYkJP.png"><br><img src="https://s2.ax1x.com/2020/02/05/1rYARf.png" alt="1rYARf.png"><br><img src="https://s2.ax1x.com/2020/02/05/1rYEz8.png" alt="1rYEz8.png"></p><ul><li>点击Run-&gt;Run  ‘app’，选择启动相应的模拟器。如果还没有模拟器，则点击工具栏的AVD Manager进行创建。<br><img src="https://s2.ax1x.com/2020/02/05/1rYZQS.png" alt="1rYZQS.png"></li><li>新建一个</li></ul><p><img src="https://s2.ax1x.com/2020/02/05/1rYesg.png" alt="1rYesg.png"></p><ul><li><p>选择Nexus 5X 按 next继续<br><img src="https://s2.ax1x.com/2020/02/05/1rYmLQ.png" alt="1rYmLQ.png"></p></li><li><p>下载一个安卓版本系统，这里我选择的 最新版本<br><img src="https://s2.ax1x.com/2020/02/05/1rYKds.png" alt="1rYKds.png"><br><img src="https://s2.ax1x.com/2020/02/05/1rYMon.png" alt="1rYMon.png"><br><img src="https://s2.ax1x.com/2020/02/05/1rYliq.png" alt="1rYliq.png"><br><img src="https://s2.ax1x.com/2020/02/05/1rY1J0.png" alt="1rY1J0.png"></p></li><li><p>下载完成后重新打开AVD Manager进行创建<br><img src="https://s2.ax1x.com/2020/02/05/1rY8zT.png" alt="1rY8zT.png"><br><img src="https://s2.ax1x.com/2020/02/05/1rYYyF.png" alt="1rYYyF.png"><br><img src="https://s2.ax1x.com/2020/02/05/1rYtL4.png" alt="1rYtL4.png"><br><img src="https://s2.ax1x.com/2020/02/05/1rYaw9.png" alt="1rYaw9.png"><br><img src="https://s2.ax1x.com/2020/02/05/1rYdoR.png" alt="1rYdoR.png"></p></li><li><p>设置环境变量<br>  点击环境变量，添加Android_SDK_ROOT变量：<br>  值：sdk的安装路径。确定并退出<br><img src="https://s2.ax1x.com/2020/02/05/1rY0F1.png" alt="1rY0F1.png"></p></li><li><p>点击 Run &gt; Run App 运行程序，运行结果如下：<br><img src="https://s2.ax1x.com/2020/02/05/1rBDMt.png" alt="1rBDMt.png"><br><img src="https://s2.ax1x.com/2020/02/05/1rB0xI.png" alt="1rB0xI.png"></p></li></ul><h6 id="PS：出现-XX-is-not-allowed-here-这一问题的解决办法，打开File-gt-Project-Structure"><a href="#PS：出现-XX-is-not-allowed-here-这一问题的解决办法，打开File-gt-Project-Structure" class="headerlink" title="PS：出现 XX is not allowed here 这一问题的解决办法，打开File-&gt;Project Structure"></a>PS：出现 XX is not allowed here 这一问题的解决办法，打开File-&gt;Project Structure</h6><p><img src="https://s2.ax1x.com/2020/02/05/1rBwRA.png" alt="1rBwRA.png"><br><img src="https://s2.ax1x.com/2020/02/05/1rBaPH.png" alt="1rBaPH.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;步骤一-系统要求&quot;&gt;&lt;a href=&quot;#步骤一-系统要求&quot; class=&quot;headerlink&quot; title=&quot;步骤一 系统要求&quot;&gt;&lt;/a&gt;步骤一 系统要求&lt;/h5&gt;&lt;p&gt;Windows 10 ；&lt;br&gt;Java JDK5 及以后版本；&lt;/p&gt;
&lt;h5 id=&quot;步
      
    
    </summary>
    
    
      <category term="软件安装" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
    
      <category term="Android Studio" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/Android-Studio/"/>
    
    
      <category term="软件安装" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
    
      <category term="Android Studio" scheme="http://yoursite.com/tags/Android-Studio/"/>
    
  </entry>
  
  <entry>
    <title>深度学习tensorflow object detect 之手势识别</title>
    <link href="http://yoursite.com/2020/01/15/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0tensorflow%20object%20detect%20%E4%B9%8B%E6%89%8B%E5%8A%BF%E8%AF%86%E5%88%AB/"/>
    <id>http://yoursite.com/2020/01/15/深度学习tensorflow object detect 之手势识别/</id>
    <published>2020-01-15T14:52:51.598Z</published>
    <updated>2020-01-16T15:42:04.488Z</updated>
    
    <content type="html"><![CDATA[<p>今天我来带大家做一个有趣的事情，识别“啪”的手势，使用<code>tensorflow object detect api</code>来检测</p><h4 id="标注"><a href="#标注" class="headerlink" title="标注"></a>标注</h4><p>首先我们使用<a href="https://github.com/sanfooh/tensorflow_label_tool" target="_blank" rel="noopener">标注工具</a>来进行标注</p><p><img src="https://s2.ax1x.com/2020/01/15/lXISPI.png" alt="lXISPI.png"></p><p>此工具是C#写的，只能用在windows环境下，输入图片的地址，按“导入”。</p><p><img src="https://s2.ax1x.com/2020/01/15/lX5jVH.png" alt="lX5jVH.png"></p><p>还有一种方法就是直接从网上找图片，输入关键字，点击启动，等待进度条完成后，导入到标注文件就好。（爬取的照片准确度不是很高，所以我拿的是自己拍的）<br><img src="https://s2.ax1x.com/2020/01/15/lX5vad.png" alt="lX5vad.png"></p><p>导入图片后我们在右侧输入要标注物体的<code>tag</code>，在图片上从左向右下角将识别的物体框住就好。</p><p><img src="https://s2.ax1x.com/2020/01/15/lX5Oqe.png" alt="lX5Oqe.png"></p><p>标注完在右下角可以看到具体的标注信息</p><p><img src="https://s2.ax1x.com/2020/01/15/lX5LrD.png" alt="lX5LrD.png"></p><p>标注完后打开图片文件夹就能看到标注的位置了</p><p><img src="https://s2.ax1x.com/2020/01/15/lX5xIA.png" alt="lX5xIA.png"></p><p>把手势全部标注完。其产生的的<code>“label_map.pbtxt”</code>和<code>“image”</code>就是我们需要的：</p><p><img src="https://s2.ax1x.com/2020/01/15/lXIpGt.png" alt="lXIpGt.png"></p><h3 id="安装tensorflow-object-detec-api（ubuntu）"><a href="#安装tensorflow-object-detec-api（ubuntu）" class="headerlink" title="安装tensorflow object detec api（ubuntu）"></a>安装tensorflow object detec api（ubuntu）</h3><p>现在我们来安装<code>tensorflow object detec api（ubuntu）</code>基于我们已经安装好了<code>tensorflow</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在根目录下创建一个output目录</span></span><br><span class="line">mkdir /output</span><br><span class="line">cd /output/</span><br><span class="line"></span><br><span class="line"><span class="comment">#下载tensorflow object detec api 代码git clone https://github.com/tensorflow/models.git</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#安装依赖项</span></span><br><span class="line">pip install Cython</span><br><span class="line">pip install pillow</span><br><span class="line">pip install lxml</span><br><span class="line">pip install jupyter</span><br><span class="line">pip install matplotlib</span><br><span class="line">pip install opencv-python</span><br><span class="line">pip install pycocotools</span><br><span class="line"></span><br><span class="line">cd /output/models/research/</span><br><span class="line"><span class="comment">#编译</span></span><br><span class="line">protoc object_detection/protos/*.proto --python_out=.</span><br><span class="line"><span class="comment">#安装export PYTHONPATH=$PYTHONPATH:`pwd`:`pwd`/slim</span></span><br><span class="line"><span class="comment">#验证python object_detection/builders/model_builder_test.py</span></span><br></pre></td></tr></table></figure><p>最后打印出“OK”即说明安装API成功<br>（代码来自<a href="https://github.com/sanfooh/tensorflow_object_detection_api_demo" target="_blank" rel="noopener">https://github.com/sanfooh/tensorflow_object_detection_api_demo</a>)</p><hr><h3 id="下载项目"><a href="#下载项目" class="headerlink" title="下载项目"></a>下载项目</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#下载图片及标注文件</span></span><br><span class="line">cd /output</span><br><span class="line">git clone https://github.com/sanfooh/tensorflow_object_detection_api_demo.git</span><br></pre></td></tr></table></figure><p>下载这个项目之后，将项目中的<code>“label_map.pbtxt”</code>和<code>“image”</code>文件夹删掉，然后把第一步产生的<code>“label_map.pbtxt”</code>和<code>“image”</code>放进去。</p><p>我们还需要下载一个预训练项目</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#下载预训练文件</span></span><br><span class="line">cd /output/tensorflow_object_detection_api_demo</span><br><span class="line">wget  http://download.tensorflow.org/models/object_detection/ssd_mobilenet_v1_coco_2017_11_17.tar.gz</span><br><span class="line">tar -xzvf ssd_mobilenet_v1_coco_2017_11_17.tar.gz</span><br><span class="line">rm -r ssd_mobilenet_v1_coco_2017_11_17.tar.gz</span><br></pre></td></tr></table></figure><p>生成tfrecord</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#生成tfrecord数据集</span></span><br><span class="line">python create_tf_record.py</span><br></pre></td></tr></table></figure><p><a href="https://imgchr.com/i/lXI9RP" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2020/01/15/lXI9RP.png" alt="lXI9RP.png"></a><br><a href="https://imgchr.com/i/lXICxf" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2020/01/15/lXICxf.png" alt="lXICxf.png"></a></p><p>生成之后我们可以看到如下的文件（<code>train.record</code>和 <code>val.record</code>）</p><p><a href="https://imgchr.com/i/lXIiM8" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2020/01/15/lXIiM8.png" alt="lXIiM8.png"></a></p><h3 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h3><p>接下来我们就开始训练</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#训练</span><br><span class="line">mkdir mytrain</span><br><span class="line">python3 /output/models/research/object_detection/legacy/train.py --train_dir=mytrain/ --pipeline_config_path=/output/tensorflow_object_detection_api_demo/net.config --logtostderr</span><br></pre></td></tr></table></figure><p><img src="https://s2.ax1x.com/2020/01/15/lXIkqg.png" alt="lXIkqg.png"><br><img src="https://s2.ax1x.com/2020/01/15/lXIEZQ.png" alt="lXIEZQ.png"></p><p>遇到缺乏’nets’解决方法，添加到环境变量中去就好</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#缺乏'nets'</span></span><br><span class="line">cd /output/models/research/</span><br><span class="line">export PYTHONPATH=$PYTHONPATH:`pwd`:`pwd`/slim</span><br></pre></td></tr></table></figure><p><img src="https://s2.ax1x.com/2020/01/15/lXIVaj.png" alt="lXIVaj.png"><br><img src="https://s2.ax1x.com/2020/01/15/lXIZIs.png" alt="lXIZIs.png"><br><img src="https://s2.ax1x.com/2020/01/15/lXInGq.png" alt="lXInGq.png"></p><p>查看训练情况</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看训练情况cd /home/aiguodong/.local/lib/python3.6/site-packages/tensorboard3python3 main.py --logdir=/output/tensorflow_object_detection_api_demo/mytrain</span></span><br></pre></td></tr></table></figure><p>打开浏览器http:/xxxx:6006就可查看训练情况<br><img src="https://s2.ax1x.com/2020/01/15/lXIuR0.png" alt="lXIuR0.png"></p><p>在训练的过程中（训练不要停），使用<code>eval.py</code>来评估验证集</p><p>首先，为了避免评估争抢<code>gpu</code>的资源，让<code>eval</code>只在<code>cpu</code>运行就好了，找到<code>/output/models/research/object_detection/legacy/eval.py</code>文件在开始的地方添加 <code>os.environ[&#39;CUDA_VISIBLE_DEVICES&#39;] = &#39;-1&#39;</code><br><img src="https://s2.ax1x.com/2020/01/15/lXIKzV.png" alt="lXIKzV.png"></p><p>PS：把<code>/output/tensorflow_object_detection_api_demo</code>下的<code>net.config</code>文件复制到<code>/output/tensorflow_object_detection_api_demo/mytrain</code> 文件夹下（两个文件一样 可以省去这步在下面代码中修改路径就好）</p><p>运行如下代码开始评估</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#开始评估cd /output/tensorflow_object_detection_api_demo</span></span><br><span class="line">mkdir eval</span><br><span class="line">python3 /output/models/research/object_detection/legacy/eval.py --logtostderr --pipeline_config_path=net.config --checkpoint_dir=mytrain/ --eval_dir=eval/</span><br></pre></td></tr></table></figure><p><img src="https://s2.ax1x.com/2020/01/15/lXIlsU.png" alt="lXIlsU.png"><br><img src="https://s2.ax1x.com/2020/01/15/lXI1LF.png" alt="lXI1LF.png"><br><img src="https://s2.ax1x.com/2020/01/15/lXI8Z4.png" alt="lXI8Z4.png"></p><p>运行后它不会退出,当有新的检查点文件产生时，它会重新评估,也就是说它是在训练的同时运行，需要注意<code>net.config</code>文件中eval部分是这样设置的<br><img src="https://s2.ax1x.com/2020/01/15/lXIGdJ.png" alt="lXIGdJ.png"></p><p>不然会报错（<code>ValueError：Image with id b&#39;xxx.jpg&#39; already added</code>）</p><p>评估时，会在<code>eval</code>目录下生成形如<code>events.out.tfevents.XXX</code>的文件<br><img src="https://s2.ax1x.com/2020/01/15/lXIJo9.png" alt="lXIJo9.png"></p><p>这时我们需要再使用<code>tensorboard</code>来查看图片情况：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看图片情况cd /output/tensorflow_object_detection_api_demo</span></span><br><span class="line">tensorboard --logdir <span class="string">"/output/tensorflow_object_detection_api_demo/eval"</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.ax1x.com/2020/01/15/lXItiR.png" alt="lXItiR.png"><br>训练完成后我们就可以发布了（注意修改13108）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#开始评估python3 /output/models/research/object_detection/export_inference_graph.py \</span></span><br><span class="line">--input_type image_tensor \</span><br><span class="line">--pipeline_config_path /output/tensorflow_object_detection_api_demo/net.config \</span><br><span class="line">--trained_checkpoint_prefix /output/tensorflow_object_detection_api_demo/mytrain/model.ckpt<span class="number">-13108</span> \<span class="number">6</span>--output_directory /output/tensorflow_object_detection_api_demo/mymodel</span><br></pre></td></tr></table></figure><p><img src="https://s2.ax1x.com/2020/01/15/lXINJ1.png" alt="lXINJ1.png"><br><img src="https://s2.ax1x.com/2020/01/15/lXIURx.png" alt="lXIURx.png"></p><p>在<code>mymodel</code>下生成如下文件，其中<code>frozen_inference_graph.pb</code>就是我们要的文件<br><img src="https://s2.ax1x.com/2020/01/15/lXIaz6.png" alt="lXIaz6.png"></p><h3 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h3><p>有了pb文件以后，我们就可以发布模型了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#利用Flask来发布模型</span></span><br><span class="line">pip install flask</span><br><span class="line">pip install flask_wtf</span><br><span class="line"><span class="comment">#启动服务python3 /output/tensorflow_object_detection_api_demo/web/app.py</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.ax1x.com/2020/01/15/lXIwQK.png" alt="lXIwQK.png"><br><img src="https://s2.ax1x.com/2020/01/15/lXI0sO.png" alt="lXI0sO.png"></p><p>最后用浏览器打开8000端口可以看到如下效果：<br><img src="https://s2.ax1x.com/2020/01/15/lXIBLD.png" alt="lXIBLD.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天我来带大家做一个有趣的事情，识别“啪”的手势，使用&lt;code&gt;tensorflow object detect api&lt;/code&gt;来检测&lt;/p&gt;
&lt;h4 id=&quot;标注&quot;&gt;&lt;a href=&quot;#标注&quot; class=&quot;headerlink&quot; title=&quot;标注&quot;&gt;&lt;/a&gt;标
      
    
    </summary>
    
    
      <category term="TensorFlow" scheme="http://yoursite.com/categories/TensorFlow/"/>
    
      <category term="pb模型训练" scheme="http://yoursite.com/categories/TensorFlow/pb%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="TensorFlow" scheme="http://yoursite.com/tags/TensorFlow/"/>
    
      <category term="手势识别" scheme="http://yoursite.com/tags/%E6%89%8B%E5%8A%BF%E8%AF%86%E5%88%AB/"/>
    
      <category term="模型训练" scheme="http://yoursite.com/tags/%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83/"/>
    
  </entry>
  
  <entry>
    <title>x的平方根</title>
    <link href="http://yoursite.com/2019/11/24/x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/"/>
    <id>http://yoursite.com/2019/11/24/x的平方根/</id>
    <published>2019-11-24T14:16:24.619Z</published>
    <updated>2019-11-25T03:27:55.471Z</updated>
    
    <content type="html"><![CDATA[<h3 id="X的平方根"><a href="#X的平方根" class="headerlink" title="X的平方根"></a>X的平方根</h3><p>实现 int sqrt(int x) 函数。</p><p>计算并返回 x 的平方根，其中 x 是非负整数。</p><p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 4</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: 8</span><br><span class="line">输出: 2</span><br><span class="line">说明: 8 的平方根是 2.82842..., </span><br><span class="line">     由于返回类型是整数，小数部分将被舍去。</span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/sqrtx" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sqrtx</a></p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>采用二分法，类似于我们猜数，大了往小了猜，小了往大的了猜。原理一致。</p><h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int mySqrt(int x)&#123;</span><br><span class="line">    if(x == 1)</span><br><span class="line">        return 1;</span><br><span class="line">    int min = 0;</span><br><span class="line">    int max = x;</span><br><span class="line">    while(max - min &gt;1)</span><br><span class="line">    &#123;</span><br><span class="line">        int m = (max + min) / 2;</span><br><span class="line">        if(x / m &lt;m)</span><br><span class="line">            max = m;</span><br><span class="line">        else</span><br><span class="line">            min = m;</span><br><span class="line">    &#125;</span><br><span class="line">    return min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>执行用时 :0 ms, 在所有 c 提交中击败了100.00%的用户<br>内存消耗 :6.8 MB, 在所有 c 提交中击败了70.89%的用户</p></blockquote><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><p>使用牛顿迭代<br>下面这种方法可以很有效地求出根号 aa 的近似值：首先随便猜一个近似值 xx，然后不断令 xx 等于 xx 和 a/xa/x 的平均数，迭代个六七次后 xx 的值就已经相当精确了。</p><p>例如，我想求根号 2 等于多少。假如我猜测的结果为 4，虽然错的离谱，但你可以看到使用牛顿迭代法后这个值很快就趋近于根号 2 了：</p><blockquote><p>( 4 + 2/ 4 ) / 2 = 2.25<br>( 2.25 + 2/ 2.25 ) / 2 = 1.56944..<br>( 1.56944..+ 2/1.56944..) / 2 = 1.42189..<br>( 1.42189..+ 2/1.42189..) / 2 = 1.41423..<br>…<br><img src="https://ftp.bmp.ovh/imgs/2019/11/3ab89e39fc70ab06.jpg" alt="示意图"></p></blockquote><p>这种算法的原理很简单，我们仅仅是不断用 (x, f(x))的切线来逼近方程 x^2-a=0 的根。根号 a实际上就是 x^2-a=0的一个正实根，这个函数的导数是 2x。也就是说，函数上任一点 (x,f(x)) 处的切线斜率是 2x。那么，x-f(x)/(2x) 就是一个比 x 更接近的近似值。代入 f(x)=x^2-a 得到 x-(x^2-a)/(2x)，也就(x+a/x)/2。<br>同样的方法可以用在其它的近似值计算中。</p><p>知道方程实现就非常简单了。</p><p>作者：LOAFER<br>链接：<a href="https://leetcode-cn.com/problems/sqrtx/solution/niu-dun-die-dai-fa-by-loafer/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sqrtx/solution/niu-dun-die-dai-fa-by-loafer/</a><br>来源：力扣（LeetCode）</p><h4 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int mySqrt(int x)&#123;</span><br><span class="line">    long r = x;</span><br><span class="line">    while(r*r &gt; x) </span><br><span class="line">        r = (r + x/r) / 2;</span><br><span class="line">    return (int)r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>执行用时 :0 ms, 在所有 c 提交中击败了100.00%的用户<br>内存消耗 :6.7 MB, 在所有 c 提交中击败了76.94%的用户</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;X的平方根&quot;&gt;&lt;a href=&quot;#X的平方根&quot; class=&quot;headerlink&quot; title=&quot;X的平方根&quot;&gt;&lt;/a&gt;X的平方根&lt;/h3&gt;&lt;p&gt;实现 int sqrt(int x) 函数。&lt;/p&gt;
&lt;p&gt;计算并返回 x 的平方根，其中 x 是非负整数。&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
      <category term="简单" scheme="http://yoursite.com/categories/Leetcode/%E7%AE%80%E5%8D%95/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="简单" scheme="http://yoursite.com/tags/%E7%AE%80%E5%8D%95/"/>
    
      <category term="二分法" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%88%86%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>合并两个有序链表</title>
    <link href="http://yoursite.com/2019/11/23/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2019/11/23/合并两个有序链表/</id>
    <published>2019-11-23T14:04:40.315Z</published>
    <updated>2019-11-23T14:04:40.318Z</updated>
    
    <content type="html"><![CDATA[<h3 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h3><p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-two-sorted-lists</a></p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>创建两个节点指针<code>head</code>,<code>l3</code>，且<code>head</code>指向<code>l3</code><br>比较<code>l1</code>和<code>l2</code>的值，小的插入<code>l3</code>里面，各自往后移动不断进行比较<br>直到其中一个链表为空了，另一个有序链表直接链接到<code>l3</code><br>返回<code>head-&gt;next</code></p><h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><pre><code>/** * Definition for singly-linked list. * struct ListNode { *     int val; *     struct ListNode *next; * }; */struct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2){    if(l1 == NULL)        return l2;    if(l2 == NULL)        return l1;    struct ListNode *l3,*head;    head = (struct ListNode*) malloc (sizeof(struct ListNode));    l3 = head;    while(l1 &amp;&amp; l2)    {        if(l1-&gt;val &lt; l2-&gt;val)        {            l3-&gt;next = l1;            l1 = l1-&gt;next;            l3 = l3-&gt;next;        }else{            l3-&gt;next = l2;            l2 = l2-&gt;next;            l3 = l3-&gt;next;        }    }    if(l1 != NULL)        l3-&gt;next = l1;    else            l3-&gt;next = l2;    return head-&gt;next;}</code></pre><blockquote><p>执行用时 :8 ms, 在所有 c 提交中击败了60.79%的用户<br>内存消耗 :7.5 MB, 在所有 c 提交中击败了77.63%的用户</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;合并两个有序链表&quot;&gt;&lt;a href=&quot;#合并两个有序链表&quot; class=&quot;headerlink&quot; title=&quot;合并两个有序链表&quot;&gt;&lt;/a&gt;合并两个有序链表&lt;/h3&gt;&lt;p&gt;将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。
      
    
    </summary>
    
    
      <category term="Leetcode链表" scheme="http://yoursite.com/categories/Leetcode%E9%93%BE%E8%A1%A8/"/>
    
      <category term="简单" scheme="http://yoursite.com/categories/Leetcode%E9%93%BE%E8%A1%A8/%E7%AE%80%E5%8D%95/"/>
    
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="简单" scheme="http://yoursite.com/tags/%E7%AE%80%E5%8D%95/"/>
    
  </entry>
  
  <entry>
    <title>不同的二叉搜索树</title>
    <link href="http://yoursite.com/2019/11/22/%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>http://yoursite.com/2019/11/22/不同的二叉搜索树/</id>
    <published>2019-11-22T14:15:37.809Z</published>
    <updated>2019-11-22T14:19:02.107Z</updated>
    
    <content type="html"><![CDATA[<h3 id="不同的二叉搜索树"><a href="#不同的二叉搜索树" class="headerlink" title="不同的二叉搜索树"></a>不同的二叉搜索树</h3><p>给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: 5</span><br><span class="line">解释:</span><br><span class="line">给定 n = 3, 一共有 5 种不同结构的二叉搜索树:</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       /     /      / \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    /     /       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/unique-binary-search-trees" target="_blank" rel="noopener">https://leetcode-cn.com/problems/unique-binary-search-trees</a></p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>二叉搜索树：<br>①若任意节点的左子树不为空，则左子树上所有结点的值均小于它根节点的值<br>②若任意节点的右子树不为空，则右子树上所有结点的值均大于它根节点的值<br>③任意结点的左、右子树也是二叉搜索树在本题中： </p><p>设dp(n)表示有n个结点时搜索二叉树有多少种可能，则</p><ol><li>当头结点的值为1时，左子树为空，右子树上有n - 1个结点，右子树的搜索二叉树个数为dp(n - 1)</li><li>当头结点的值为i(1 &lt; i &lt; n)时，左子树由结点1—&gt;i-1构成，右子树由结点i+1—&gt;n构成；左子树的搜索二叉树个数为dp(i-1),右子树的搜索二叉树个数为dp(n - i);此时搜索二叉树总的个数为dp(i - 1) * dp(n - i)</li><li>当头结点的值为n时，右子树为空，左子树上有n - 1个结点，左子树的搜索二叉树个数为dp(n - 1)所以，n个结点时搜索二叉树的个数上述三个步骤的和。</li></ol><p>递推公式：<br>dp(n)=dp(0)dp(n-1)+dp(1)dp(n-2)+dp(2)dp(n-3)+…+dp(n-1)dp(0)</p><h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int numTrees(int n)&#123;</span><br><span class="line">    int dp[n+1];</span><br><span class="line">    dp[0] = 1;</span><br><span class="line">    dp[1] = 1;</span><br><span class="line">    for(int i = 2; i &lt; n+1; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for(int j = 1; j &lt; i+1; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += dp[j-1] * dp[i-j];</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i] = sum;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>执行用时 :0 ms, 在所有 c 提交中击败了100.00%的用户<br>内存消耗 :6.7 MB, 在所有 c 提交中击败了28.95%的用户</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;不同的二叉搜索树&quot;&gt;&lt;a href=&quot;#不同的二叉搜索树&quot; class=&quot;headerlink&quot; title=&quot;不同的二叉搜索树&quot;&gt;&lt;/a&gt;不同的二叉搜索树&lt;/h3&gt;&lt;p&gt;给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？&lt;/p&gt;
&lt;p&gt;示例:&lt;
      
    
    </summary>
    
    
      <category term="Leetcode二叉树" scheme="http://yoursite.com/categories/Leetcode%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="二叉搜索树" scheme="http://yoursite.com/categories/Leetcode%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
      <category term="动态规划" scheme="http://yoursite.com/categories/Leetcode%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="中等" scheme="http://yoursite.com/categories/Leetcode%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E4%B8%AD%E7%AD%89/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="二叉搜索树" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
      <category term="中等" scheme="http://yoursite.com/tags/%E4%B8%AD%E7%AD%89/"/>
    
  </entry>
  
  <entry>
    <title>爬楼梯</title>
    <link href="http://yoursite.com/2019/11/21/%E7%88%AC%E6%A5%BC%E6%A2%AF/"/>
    <id>http://yoursite.com/2019/11/21/爬楼梯/</id>
    <published>2019-11-21T12:41:04.964Z</published>
    <updated>2019-11-21T12:41:04.968Z</updated>
    
    <content type="html"><![CDATA[<h3 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h3><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p>注意：给定 n 是一个正整数。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入： 2</span><br><span class="line">输出： 2</span><br><span class="line">解释： 有两种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶</span><br><span class="line">2.  2 阶</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入： 3</span><br><span class="line">输出： 3</span><br><span class="line">解释： 有三种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶 + 1 阶</span><br><span class="line">2.  1 阶 + 2 阶</span><br><span class="line">3.  2 阶 + 1 阶</span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/climbing-stairs" target="_blank" rel="noopener">https://leetcode-cn.com/problems/climbing-stairs</a></p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>通过查找规律，很容易发现这个的结果就是，斐波那契数。所以使用解决斐波那契数的方法解决</p><h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int climbStairs(int n)&#123;</span><br><span class="line">    int a = 0, b = 1, c = 0;</span><br><span class="line">    while (n--)&#123;</span><br><span class="line">        c = a + b;</span><br><span class="line">        a = b;</span><br><span class="line">        b = c;</span><br><span class="line">    &#125;</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>执行用时 :4 ms, 在所有 c 提交中击败了63.56%的用户<br>内存消耗 :6.8 MB, 在所有 c 提交中击败了52.18%的用户</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;爬楼梯&quot;&gt;&lt;a href=&quot;#爬楼梯&quot; class=&quot;headerlink&quot; title=&quot;爬楼梯&quot;&gt;&lt;/a&gt;爬楼梯&lt;/h3&gt;&lt;p&gt;假设你正在爬楼梯。需要 n 阶你才能到达楼顶。&lt;/p&gt;
&lt;p&gt;每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
      
    
    </summary>
    
    
      <category term="Leetcode递归" scheme="http://yoursite.com/categories/Leetcode%E9%80%92%E5%BD%92/"/>
    
      <category term="斐波那契数" scheme="http://yoursite.com/categories/Leetcode%E9%80%92%E5%BD%92/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/"/>
    
      <category term="递归" scheme="http://yoursite.com/categories/Leetcode%E9%80%92%E5%BD%92/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/%E9%80%92%E5%BD%92/"/>
    
      <category term="简单" scheme="http://yoursite.com/categories/Leetcode%E9%80%92%E5%BD%92/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/%E9%80%92%E5%BD%92/%E7%AE%80%E5%8D%95/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="递归" scheme="http://yoursite.com/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="简单" scheme="http://yoursite.com/tags/%E7%AE%80%E5%8D%95/"/>
    
      <category term="斐波那契数" scheme="http://yoursite.com/tags/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>删除链表的倒数第N个结点</title>
    <link href="http://yoursite.com/2019/11/21/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E7%BB%93%E7%82%B9/"/>
    <id>http://yoursite.com/2019/11/21/删除链表的倒数第N个结点/</id>
    <published>2019-11-21T11:56:15.763Z</published>
    <updated>2019-11-21T12:39:46.375Z</updated>
    
    <content type="html"><![CDATA[<h3 id="删除链表的倒数第N个结点"><a href="#删除链表的倒数第N个结点" class="headerlink" title="删除链表的倒数第N个结点"></a>删除链表的倒数第N个结点</h3><p>给定一个链表，删除链表的倒数第<code>n</code> 个节点，并且返回链表的头结点。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.</span><br><span class="line"></span><br><span class="line">当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</span><br></pre></td></tr></table></figure><p>说明：</p><p>给定的 n 保证是有效的。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list" target="_blank" rel="noopener">https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list</a></p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>我们可以假设设置了双指针<code>fast</code> 和 <code>slow</code> ，当 <code>fast</code>指向末尾的 <code>NULL</code>，<code>fast</code>和 <code>slow</code> 之间相隔的元素个数为<code>n</code>时，那么删除掉<code>slow</code>的下一个指针就完成了要求</p><ul><li>设置虚拟结点 <code>node</code> 指向 <code>head</code></li><li>设定双指针 <code>fast</code> 和 <code>slow</code>，<code>fast</code>指向 <code>head</code>，<code>slow</code>指向<code>head</code>。</li><li>移动 <code>fast</code>直到<code>fast</code> 与 <code>slow</code>之间相隔的元素个数为<code>n</code></li><li>同时移动 <code>fast</code>和<code>slow</code>直到 <code>fast</code> 指向的为<code>NULL</code></li><li>将 <code>slow</code>的下个节点指向下下个节点</li></ul><h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     struct ListNode *next;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">struct ListNode* removeNthFromEnd(struct ListNode* head, int n)&#123;</span><br><span class="line">    if(head == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">    struct ListNode node;</span><br><span class="line">    node.next = head;</span><br><span class="line">    struct ListNode * fast = head;</span><br><span class="line">    struct ListNode * slow = &amp;node;</span><br><span class="line">    int i = 1;</span><br><span class="line">    while(fast != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        if(i &gt; n)//fast 与 slow 的间隔 为n的时候，两个指针一起移动</span><br><span class="line">        &#123;</span><br><span class="line">            slow = slow -&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = fast-&gt; next;</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    slow -&gt; next = slow-&gt;next-&gt;next;</span><br><span class="line">    return node.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>执行用时 :8 ms, 在所有 c 提交中击败了37.41%的用户<br>内存消耗 :6.9 MB, 在所有 c 提交中击败了91.62%的用户</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;删除链表的倒数第N个结点&quot;&gt;&lt;a href=&quot;#删除链表的倒数第N个结点&quot; class=&quot;headerlink&quot; title=&quot;删除链表的倒数第N个结点&quot;&gt;&lt;/a&gt;删除链表的倒数第N个结点&lt;/h3&gt;&lt;p&gt;给定一个链表，删除链表的倒数第&lt;code&gt;n&lt;/code&gt; 
      
    
    </summary>
    
    
      <category term="Leetcode链表" scheme="http://yoursite.com/categories/Leetcode%E9%93%BE%E8%A1%A8/"/>
    
      <category term="双指针" scheme="http://yoursite.com/categories/Leetcode%E9%93%BE%E8%A1%A8/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="中等" scheme="http://yoursite.com/categories/Leetcode%E9%93%BE%E8%A1%A8/%E5%8F%8C%E6%8C%87%E9%92%88/%E4%B8%AD%E7%AD%89/"/>
    
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="中等" scheme="http://yoursite.com/tags/%E4%B8%AD%E7%AD%89/"/>
    
      <category term="双指针" scheme="http://yoursite.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>加一</title>
    <link href="http://yoursite.com/2019/11/19/%E5%8A%A0%E4%B8%80/"/>
    <id>http://yoursite.com/2019/11/19/加一/</id>
    <published>2019-11-19T14:22:00.164Z</published>
    <updated>2019-11-19T14:22:00.167Z</updated>
    
    <content type="html"><![CDATA[<h3 id="加一"><a href="#加一" class="headerlink" title="加一"></a>加一</h3><p>给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。</p><p>最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。</p><p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">输出: [1,2,4]</span><br><span class="line">解释: 输入数组表示数字 123。</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [4,3,2,1]</span><br><span class="line">输出: [4,3,2,2]</span><br><span class="line">解释: 输入数组表示数字 4321。</span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/plus-one" target="_blank" rel="noopener">https://leetcode-cn.com/problems/plus-one</a></p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>第一种情况：直接给数组最后一位的数字加一<br>第二种情况：1119 最后一位（最高位不为9）数字加一，会向前进一<br>第三种情况：999 每一位加都进一，且最高位为9，我们就需要动态开辟一个空间，空间大小为原数组大小加一</p><h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int* plusOne(int* digits, int digitsSize, int* returnSize)&#123;</span><br><span class="line">    if(digitsSize == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        return digits;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = digitsSize - 1; i&gt;= 0; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        digits[i] = (digits[i] + 1) % 10;</span><br><span class="line">        if(digits[i] != 0)</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    * returnSize = digitsSize;</span><br><span class="line">    if(digits[0] == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        int *result = (int *) malloc (sizeof(int) * (digitsSize+1));</span><br><span class="line">        result[0] = 1;</span><br><span class="line">        for(int k =1; k&lt;digitsSize+1; ++k)</span><br><span class="line">        &#123;</span><br><span class="line">            result[k] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        *returnSize = digitsSize + 1;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">        return digits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>执行用时 :4 ms, 在所有 c 提交中击败了80.94%的用户<br>内存消耗 :7.2 MB, 在所有 c 提交中击败了5.51%的用户</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;加一&quot;&gt;&lt;a href=&quot;#加一&quot; class=&quot;headerlink&quot; title=&quot;加一&quot;&gt;&lt;/a&gt;加一&lt;/h3&gt;&lt;p&gt;给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。&lt;/p&gt;
&lt;p&gt;最高位数字存放在数组的首位， 数组中每个元素只存储单个数字
      
    
    </summary>
    
    
      <category term="Leetcode数组" scheme="http://yoursite.com/categories/Leetcode%E6%95%B0%E7%BB%84/"/>
    
      <category term="动态分配" scheme="http://yoursite.com/categories/Leetcode%E6%95%B0%E7%BB%84/%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D/"/>
    
      <category term="简单" scheme="http://yoursite.com/categories/Leetcode%E6%95%B0%E7%BB%84/%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D/%E7%AE%80%E5%8D%95/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="简单" scheme="http://yoursite.com/tags/%E7%AE%80%E5%8D%95/"/>
    
      <category term="动态分配" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>罗马数字转整数</title>
    <link href="http://yoursite.com/2019/11/18/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/"/>
    <id>http://yoursite.com/2019/11/18/罗马数字转整数/</id>
    <published>2019-11-18T14:20:32.439Z</published>
    <updated>2019-11-18T14:20:32.510Z</updated>
    
    <content type="html"><![CDATA[<h3 id="罗马数字转整数"><a href="#罗马数字转整数" class="headerlink" title="罗马数字转整数"></a>罗马数字转整数</h3><p>罗马数字包含以下七种字符:<code>I， V， X， L，C，D 和 M</code>。</p><table><thead><tr><th>字符</th><th>数值</th></tr></thead><tbody><tr><td>I</td><td>1</td></tr><tr><td>V</td><td>5</td></tr><tr><td>X</td><td>10</td></tr><tr><td>L</td><td>50</td></tr><tr><td>C</td><td>100</td></tr><tr><td>D</td><td>500</td></tr><tr><td>M</td><td>1000</td></tr><tr><td>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</td><td></td></tr></tbody></table><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p><ul><li>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。</li><li>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 </li><li>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</li></ul><p>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;III&quot;</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;IV&quot;</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><p>示例 3:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;IX&quot;</span><br><span class="line">输出: 9</span><br></pre></td></tr></table></figure><p>示例 4:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;LVIII&quot;</span><br><span class="line">输出: 58</span><br><span class="line">解释: L = 50, V= 5, III = 3.</span><br></pre></td></tr></table></figure><p>示例 5:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;MCMXCIV&quot;</span><br><span class="line">输出: 1994</span><br><span class="line">解释: M = 1000, CM = 900, XC = 90, IV = 4.</span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/roman-to-integer" target="_blank" rel="noopener">https://leetcode-cn.com/problems/roman-to-integer</a></p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>用<code>switch()</code>解决，判断字符串中每个字符，与罗马字符对应，结果加上罗马字母对应的值， 比较字符串中<code>I、X 、C</code>字符 <code>s[i]</code>与<code>s[i+1]</code>是否符合</p><pre><code>1. I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。2. X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 903.C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900</code></pre><p>这六种情况,如果符合，则结果减去 <code>2</code>倍的 <code>s[i]</code>罗马字母对应的值，因为本来要减去的值，之前多加了一个，所以要减去二倍的 罗马值。</p><h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int change(char c)</span><br><span class="line">&#123;</span><br><span class="line">    switch (c)</span><br><span class="line">    &#123;</span><br><span class="line">        case &apos;I&apos;: return 1;</span><br><span class="line">        case &apos;V&apos;: return 5;</span><br><span class="line">        case &apos;X&apos;: return 10;</span><br><span class="line">        case &apos;L&apos;: return 50;</span><br><span class="line">        case &apos;C&apos;: return 100;</span><br><span class="line">        case &apos;D&apos;: return 500;</span><br><span class="line">        case &apos;M&apos;: return 1000;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">int romanToInt(char * s)</span><br><span class="line">&#123;</span><br><span class="line">    int i = 0;</span><br><span class="line">    int result = 0;</span><br><span class="line">    while (s[i] != &apos;\0&apos;) &#123;</span><br><span class="line">        if (s[i] == &apos;I&apos; &amp;&amp; s[i + 1] == &apos;V&apos;) &#123;</span><br><span class="line">            result += 4;</span><br><span class="line">            i += 2;</span><br><span class="line">        &#125; else if (s[i] == &apos;I&apos; &amp;&amp; s[i + 1] == &apos;X&apos;) &#123;</span><br><span class="line">            result += 9;</span><br><span class="line">            i += 2;</span><br><span class="line">        &#125; else if (s[i] == &apos;X&apos; &amp;&amp; s[i + 1] == &apos;L&apos;) &#123;</span><br><span class="line">            result += 40;</span><br><span class="line">            i += 2;</span><br><span class="line">        &#125; else if (s[i] == &apos;X&apos; &amp;&amp; s[i + 1] == &apos;C&apos;) &#123;</span><br><span class="line">            result += 90;</span><br><span class="line">            i += 2;</span><br><span class="line">        &#125; else if (s[i] == &apos;C&apos; &amp;&amp; s[i + 1] == &apos;D&apos;) &#123;</span><br><span class="line">            result += 400;</span><br><span class="line">            i += 2;</span><br><span class="line">        &#125; else if (s[i] == &apos;C&apos; &amp;&amp; s[i + 1] == &apos;M&apos;) &#123;</span><br><span class="line">            result += 900;</span><br><span class="line">            i += 2;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            result += change(s[i]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>执行用时 :20 ms, 在所有 c 提交中击败了14.17%的用户<br>内存消耗 :7.2 MB, 在所有 c 提交中击败了79.18%的用户</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">int romanToInt(char * s)&#123;</span><br><span class="line">    int len = strlen(s);</span><br><span class="line">    if (len == 0)</span><br><span class="line">        return 0;</span><br><span class="line">    int ans = 0;</span><br><span class="line">    </span><br><span class="line">    for(int i=0; i &lt; len; ++i) &#123;</span><br><span class="line">        switch (s[i]) &#123;</span><br><span class="line">            case &apos;M&apos;: ans+=1000;break;</span><br><span class="line">            case &apos;D&apos;: ans+=500;break;  </span><br><span class="line">            case &apos;C&apos;: ans+=100; </span><br><span class="line">                if(i &lt; (len - 1)) </span><br><span class="line">                    if(s[i+1] == &apos;M&apos; || s[i+1] == &apos;D&apos;) </span><br><span class="line">                        ans-=200; </span><br><span class="line">                break;</span><br><span class="line">            case &apos;L&apos;: ans+=50; break;</span><br><span class="line">            case &apos;X&apos;: ans+=10; </span><br><span class="line">                if(i &lt; (len - 1)) </span><br><span class="line">                    if(s[i+1] == &apos;L&apos; || s[i+1] == &apos;C&apos;) </span><br><span class="line">                    ans-=20; </span><br><span class="line">                break;</span><br><span class="line">            case &apos;V&apos;: ans+=5;  break;</span><br><span class="line">            case &apos;I&apos;: ans+=1;  </span><br><span class="line">                if(i &lt; (len - 1)) </span><br><span class="line">                    if(s[i+1] == &apos;X&apos; || s[i+1] == &apos;V&apos;) </span><br><span class="line">                        ans-=2; </span><br><span class="line">                break;</span><br><span class="line">            default: break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>执行用时 :12 ms, 在所有 c 提交中击败了58.66%的用户<br>内存消耗 :7.2 MB, 在所有 c 提交中击败了79.05%的用户</p></blockquote><p>以上两种代码实现方式，第二种比第一种，用时短减少了很多<code>if..else</code>判断。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;罗马数字转整数&quot;&gt;&lt;a href=&quot;#罗马数字转整数&quot; class=&quot;headerlink&quot; title=&quot;罗马数字转整数&quot;&gt;&lt;/a&gt;罗马数字转整数&lt;/h3&gt;&lt;p&gt;罗马数字包含以下七种字符:&lt;code&gt;I， V， X， L，C，D 和 M&lt;/code&gt;。&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="Leetcode字符串" scheme="http://yoursite.com/categories/Leetcode%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="回文数" scheme="http://yoursite.com/categories/Leetcode%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%9B%9E%E6%96%87%E6%95%B0/"/>
    
      <category term="简单" scheme="http://yoursite.com/categories/Leetcode%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%9B%9E%E6%96%87%E6%95%B0/%E7%AE%80%E5%8D%95/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="简单" scheme="http://yoursite.com/tags/%E7%AE%80%E5%8D%95/"/>
    
      <category term="字符串" scheme="http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="字符转换" scheme="http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E8%BD%AC%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>回文数</title>
    <link href="http://yoursite.com/2019/11/16/%E5%9B%9E%E6%96%87%E6%95%B0/"/>
    <id>http://yoursite.com/2019/11/16/回文数/</id>
    <published>2019-11-16T14:33:22.766Z</published>
    <updated>2019-11-17T05:13:01.261Z</updated>
    
    <content type="html"><![CDATA[<pre><code>回文数</code></pre><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 121</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: -121</span><br><span class="line">输出: false</span><br><span class="line">解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure><p>示例 3:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 10</span><br><span class="line">输出: false</span><br><span class="line">解释: 从右向左读, 为 01 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/palindrome-number" target="_blank" rel="noopener">https://leetcode-cn.com/problems/palindrome-number</a></p><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><p>如果给的数字是负数，则一定不是回文数</p><ol><li>将整数倒置，判断与原整数是否相同。</li><li>将整数转化为字符串<code>a[]</code>，<code>a[i]</code>是字符串第一个元素，<code>a[j]</code>是字符串最后一个元素，判断<code>a[i]</code>与<code>a[j]</code>是否相等，如果相等 <code>i++,j++</code> 直到<code>a[i] == a[j]</code>,则返回<code>true</code>,如果不想等直接返回<code>false</code>。</li></ol><h4 id="完整代码（1）"><a href="#完整代码（1）" class="headerlink" title="完整代码（1）"></a>完整代码（1）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">bool isPalindrome(int x)&#123;</span><br><span class="line">    if(x &lt; 0)</span><br><span class="line">        return false;</span><br><span class="line">    long f = 0;</span><br><span class="line">    int temp = x;</span><br><span class="line">    for(;x;f = f * 10 +x % 10,x/=10);</span><br><span class="line">    if( temp == f &amp;&amp; temp &gt;= 0)</span><br><span class="line">        return true;</span><br><span class="line">    else</span><br><span class="line">        return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>执行用时 :8 ms, 在所有 c 提交中击败了92.91%的用户<br>内存消耗 :7 MB, 在所有 c 提交中击败了93.11%的用户</p></blockquote><h4 id="完整代码（2）"><a href="#完整代码（2）" class="headerlink" title="完整代码（2）"></a>完整代码（2）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">// itoa 是实现将整数转换为字符串的方法</span><br><span class="line">char* itoa(int num,char* str,int radix)</span><br><span class="line">&#123;</span><br><span class="line">char index[]=&quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;//索引表</span><br><span class="line">unsigned unum;//存放要转换的整数的绝对值,转换的整数可能是负数</span><br><span class="line">int i=0,j,k;//i用来指示设置字符串相应位，转换之后i其实就是字符串的长度；转换后顺序是逆序的，有正负的情况，k用来指示调整顺序的开始位置;j用来指示调整顺序时的交换。</span><br><span class="line"> </span><br><span class="line">//获取要转换的整数的绝对值</span><br><span class="line">if(radix==10&amp;&amp;num&lt;0)//要转换成十进制数并且是负数</span><br><span class="line">&#123;</span><br><span class="line">unum=(unsigned)-num;//将num的绝对值赋给unum</span><br><span class="line">str[i++]=&apos;-&apos;;//在字符串最前面设置为&apos;-&apos;号，并且索引加1</span><br><span class="line">&#125;</span><br><span class="line">else unum=(unsigned)num;//若是num为正，直接赋值给unum</span><br><span class="line"> </span><br><span class="line">//转换部分，注意转换后是逆序的</span><br><span class="line">do</span><br><span class="line">&#123;</span><br><span class="line">str[i++]=index[unum%(unsigned)radix];//取unum的最后一位，并设置为str对应位，指示索引加1</span><br><span class="line">unum/=radix;//unum去掉最后一位</span><br><span class="line"> </span><br><span class="line">&#125;while(unum);//直至unum为0退出循环</span><br><span class="line"> </span><br><span class="line">str[i]=&apos;\0&apos;;//在字符串最后添加&apos;\0&apos;字符，c语言字符串以&apos;\0&apos;结束。</span><br><span class="line"> </span><br><span class="line">//将顺序调整过来</span><br><span class="line">if(str[0]==&apos;-&apos;) k=1;//如果是负数，符号不用调整，从符号后面开始调整</span><br><span class="line">else k=0;//不是负数，全部都要调整</span><br><span class="line"> </span><br><span class="line">char temp;//临时变量，交换两个值时用到</span><br><span class="line">for(j=k;j&lt;=(i-1)/2;j++)//头尾一一对称交换，i其实就是字符串的长度，索引最大值比长度少1</span><br><span class="line">&#123;</span><br><span class="line">temp=str[j];//头部赋值给临时变量</span><br><span class="line">str[j]=str[i-1+k-j];//尾部赋值给头部</span><br><span class="line">str[i-1+k-j]=temp;//将临时变量的值(其实就是之前的头部值)赋给尾部</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">return str;//返回转换后的字符串</span><br><span class="line">&#125;</span><br><span class="line">bool isPalindrome(int x)&#123;</span><br><span class="line">    if(x &lt; 0)</span><br><span class="line">        return false;</span><br><span class="line">    char string[100] = &#123;0&#125;;</span><br><span class="line">    itoa(x,string,10);</span><br><span class="line">    int i = 0, j = strlen(string);</span><br><span class="line">    for(i = 0; i != j &amp;&amp; j &gt;0 ; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        if(string[i] != string[j-1])</span><br><span class="line">            return false;</span><br><span class="line">        --j;</span><br><span class="line">    &#125; </span><br><span class="line">    return true;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>执行用时 :16 ms, 在所有 c 提交中击败了58.54%的用户<br>内存消耗 :7.2 MB, 在所有 c 提交中击败了82.37%的用户</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;回文数&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td c
      
    
    </summary>
    
    
      <category term="Leetcode整数" scheme="http://yoursite.com/categories/Leetcode%E6%95%B4%E6%95%B0/"/>
    
      <category term="回文数" scheme="http://yoursite.com/categories/Leetcode%E6%95%B4%E6%95%B0/%E5%9B%9E%E6%96%87%E6%95%B0/"/>
    
      <category term="简单" scheme="http://yoursite.com/categories/Leetcode%E6%95%B4%E6%95%B0/%E5%9B%9E%E6%96%87%E6%95%B0/%E7%AE%80%E5%8D%95/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="简单" scheme="http://yoursite.com/tags/%E7%AE%80%E5%8D%95/"/>
    
      <category term="整数" scheme="http://yoursite.com/tags/%E6%95%B4%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>最长回文子串</title>
    <link href="http://yoursite.com/2019/11/15/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <id>http://yoursite.com/2019/11/15/最长回文子串/</id>
    <published>2019-11-15T14:10:27.001Z</published>
    <updated>2019-11-15T14:10:27.002Z</updated>
    
    <content type="html"><![CDATA[<h3 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h3><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;babad&quot;</span><br><span class="line">输出: &quot;bab&quot;</span><br><span class="line">注意: &quot;aba&quot; 也是一个有效答案。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;cbbd&quot;</span><br><span class="line">输出: &quot;bb&quot;</span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/longest-palindromic-substring" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-palindromic-substring</a></p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">char * longestPalindrome(char * s)&#123;</span><br><span class="line">    int len = strlen(s);</span><br><span class="line">    int maxSubStrLen = 0;</span><br><span class="line">    int startIdx, endIdx;</span><br><span class="line">    int searchIdx = 0, searchLen = 1;</span><br><span class="line">    int i, m, n;</span><br><span class="line">    if (len &lt;= 1) &#123;</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line">    while (searchIdx &lt; len) &#123;</span><br><span class="line">        for (i = searchIdx + 1; i &lt; len; i++)&#123;</span><br><span class="line">            if (s[searchIdx] != s[i]) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            searchLen++;</span><br><span class="line">        &#125;</span><br><span class="line">        m = i;</span><br><span class="line">        n = searchIdx - 1;</span><br><span class="line">        while ((n &gt;= 0) &amp;&amp; (m &lt; len)) &#123;</span><br><span class="line">            if (s[n] != s[m]) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            m++;</span><br><span class="line">            n--;</span><br><span class="line">            searchLen += 2;   </span><br><span class="line">        &#125;</span><br><span class="line">        if (searchLen &gt; maxSubStrLen)&#123;</span><br><span class="line">            maxSubStrLen = searchLen;</span><br><span class="line">            startIdx = n + 1;</span><br><span class="line">            endIdx = m - 1;</span><br><span class="line">        &#125;</span><br><span class="line">        searchLen = 1;</span><br><span class="line">        searchIdx ++;</span><br><span class="line">    &#125;</span><br><span class="line">    s[endIdx + 1] = &apos;\0&apos;;</span><br><span class="line">    return &amp;s[startIdx];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>执行用时 :12 ms, 在所有 c 提交中击败了96.12%的用户<br>内存消耗 :7.2 MB, 在所有 c 提交中击败了80.99%的用户</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;最长回文子串&quot;&gt;&lt;a href=&quot;#最长回文子串&quot; class=&quot;headerlink&quot; title=&quot;最长回文子串&quot;&gt;&lt;/a&gt;最长回文子串&lt;/h3&gt;&lt;p&gt;给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。&lt;/p&gt;
&lt;p&gt;示例
      
    
    </summary>
    
    
      <category term="Leetcode字符串" scheme="http://yoursite.com/categories/Leetcode%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="滑动窗口" scheme="http://yoursite.com/categories/Leetcode%E5%AD%97%E7%AC%A6%E4%B8%B2/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
      <category term="中等" scheme="http://yoursite.com/categories/Leetcode%E5%AD%97%E7%AC%A6%E4%B8%B2/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/%E4%B8%AD%E7%AD%89/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="中等" scheme="http://yoursite.com/tags/%E4%B8%AD%E7%AD%89/"/>
    
      <category term="字符串" scheme="http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="字符串的操作" scheme="http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>盛最多水的容器</title>
    <link href="http://yoursite.com/2019/11/14/%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/"/>
    <id>http://yoursite.com/2019/11/14/盛最多水的容器/</id>
    <published>2019-11-14T14:26:29.979Z</published>
    <updated>2019-11-14T14:30:18.016Z</updated>
    
    <content type="html"><![CDATA[<h3 id="盛最多水的容器"><a href="#盛最多水的容器" class="headerlink" title="盛最多水的容器"></a>盛最多水的容器</h3><p>给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p>说明：你不能倾斜容器，且 n 的值至少为 2。</p><p><img src="http://tva1.sinaimg.cn/large/0080ySGmly1g8xxf5axnej30m90anwep.jpg" alt="示意图"></p> <center> <font size=3>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</font></center>来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/container-with-most-water<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>用<code>k = heightSize - 1</code> ,比较<code>height[i]与height[k]</code>的大小，如果<code>height[i]</code>比<code>height[k]</code>大，用 <code>height[k] * (heightSize - 1 )，k--</code> 如果<code>height[i]</code>比<code>height[k]</code>小，用<code>height[i] * (heightSize - 1 )，i++</code> 逐一计算 每一个面积 ，最后获取最大的面积。</p><h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int maxArea(int* height, int heightSize) &#123;</span><br><span class="line">    int area = 0;</span><br><span class="line">    int i = 0;</span><br><span class="line">    int k = heightSize -1;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        int temp_area;</span><br><span class="line">        if ( heightSize - 1 == 0)</span><br><span class="line">            break;</span><br><span class="line">        if (height[i] &gt; height[k]) &#123;</span><br><span class="line">            temp_area = height[k]*(heightSize - 1);</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            temp_area = height[i]*(heightSize - 1);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        if (temp_area &gt; area)</span><br><span class="line">            area = temp_area;</span><br><span class="line">        heightSize--;</span><br><span class="line">    &#125;</span><br><span class="line">    return area;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>执行用时 :20 ms, 在所有 c 提交中击败了82.21%的用户<br>内存消耗 :7.9 MB, 在所有 c 提交中击败了48.80%的用户</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;盛最多水的容器&quot;&gt;&lt;a href=&quot;#盛最多水的容器&quot; class=&quot;headerlink&quot; title=&quot;盛最多水的容器&quot;&gt;&lt;/a&gt;盛最多水的容器&lt;/h3&gt;&lt;p&gt;给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 
      
    
    </summary>
    
    
      <category term="Leetcode数组" scheme="http://yoursite.com/categories/Leetcode%E6%95%B0%E7%BB%84/"/>
    
      <category term="循环" scheme="http://yoursite.com/categories/Leetcode%E6%95%B0%E7%BB%84/%E5%BE%AA%E7%8E%AF/"/>
    
      <category term="中等" scheme="http://yoursite.com/categories/Leetcode%E6%95%B0%E7%BB%84/%E5%BE%AA%E7%8E%AF/%E4%B8%AD%E7%AD%89/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="中等" scheme="http://yoursite.com/tags/%E4%B8%AD%E7%AD%89/"/>
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="数组的操作" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84%E7%9A%84%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>买卖股票的最佳时期</title>
    <link href="http://yoursite.com/2019/11/13/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%9F/"/>
    <id>http://yoursite.com/2019/11/13/买卖股票的最佳时期/</id>
    <published>2019-11-13T14:23:53.784Z</published>
    <updated>2019-11-13T14:23:53.785Z</updated>
    
    <content type="html"><![CDATA[<h3 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a>买卖股票的最佳时机</h3><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p><p>注意你不能在买入股票前卖出股票。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br><span class="line">     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock</a></p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>遍历当前这个数字与后面每一个大于他的数字的差值，取得所有差值中最大的一个，这个实现起来不难。</p><h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> int maxProfit(int* prices, int pricesSize)&#123;</span><br><span class="line">    if(pricesSize == 0 || pricesSize == 1)</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int max=0,min = prices[0];</span><br><span class="line">    </span><br><span class="line">    for(int i = 1; i&lt;pricesSize;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        if(prices[i] - min &gt; max)</span><br><span class="line">            max = prices[i] - min;</span><br><span class="line">        if(prices[i] &lt; min )</span><br><span class="line">            min = prices[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>执行用时 :12 ms, 在所有 c 提交中击败了60.05%的用户<br>内存消耗 :7.9 MB, 在所有 c 提交中击败了5.25%的用户</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;买卖股票的最佳时机&quot;&gt;&lt;a href=&quot;#买卖股票的最佳时机&quot; class=&quot;headerlink&quot; title=&quot;买卖股票的最佳时机&quot;&gt;&lt;/a&gt;买卖股票的最佳时机&lt;/h3&gt;&lt;p&gt;给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。&lt;/p&gt;
&lt;p&gt;如果
      
    
    </summary>
    
    
      <category term="Leetcode数组" scheme="http://yoursite.com/categories/Leetcode%E6%95%B0%E7%BB%84/"/>
    
      <category term="循环" scheme="http://yoursite.com/categories/Leetcode%E6%95%B0%E7%BB%84/%E5%BE%AA%E7%8E%AF/"/>
    
      <category term="简单" scheme="http://yoursite.com/categories/Leetcode%E6%95%B0%E7%BB%84/%E5%BE%AA%E7%8E%AF/%E7%AE%80%E5%8D%95/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="简单" scheme="http://yoursite.com/tags/%E7%AE%80%E5%8D%95/"/>
    
  </entry>
  
  <entry>
    <title>整数反转</title>
    <link href="http://yoursite.com/2019/11/12/%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/"/>
    <id>http://yoursite.com/2019/11/12/整数反转/</id>
    <published>2019-11-12T14:27:41.293Z</published>
    <updated>2019-11-12T14:27:41.314Z</updated>
    
    <content type="html"><![CDATA[<h3 id="整数反转"><a href="#整数反转" class="headerlink" title="整数反转"></a>整数反转</h3><p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 123</span><br><span class="line">输出: 321</span><br></pre></td></tr></table></figure><p> 示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: -123</span><br><span class="line">输出: -321</span><br></pre></td></tr></table></figure><p>示例 3:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 120</span><br><span class="line">输出: 21</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><p>假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/reverse-integer" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-integer</a></p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>获取整数各个位置上的数字，并且使用 <code>count</code>用来记录有几位数字，<code>result =result*10+ a[i] ;</code>得到结果，其余就是要判断溢出问题和 负数问题</p><h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int reverse(int x)&#123;</span><br><span class="line">    int a[10] = &#123;0&#125;;</span><br><span class="line">    long result = 0;</span><br><span class="line">    int count = 0;</span><br><span class="line">    int temp = x;</span><br><span class="line">    int max = 0x7fffffff, min = 0x80000000;//int的最大值最小值</span><br><span class="line">    for(int i = 0; temp != 0; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i] = temp % 10;</span><br><span class="line">        temp = temp / 10;</span><br><span class="line">        count ++;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = 0; i &lt; count; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        result =result*10+ a[i] ;</span><br><span class="line">       // result *= 10;</span><br><span class="line">    &#125;</span><br><span class="line">    if(result &gt;max || result &lt; min)</span><br><span class="line">        return 0;</span><br><span class="line">    else if(x &lt; 0)</span><br><span class="line">        return result * -1;</span><br><span class="line">    else </span><br><span class="line">        return result;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>执行用时 :0 ms, 在所有 c 提交中击败了100.00%的用户<br>内存消耗 :6.9 MB, 在所有 c 提交中击败了75.39%的用户</p></blockquote><p>在LeetCode平台中看到评论区有位 作者：止于至善<br>代码非常简洁明了，我在这也给贴出来，供大家学习交流！</p><h4 id="其他实现代码"><a href="#其他实现代码" class="headerlink" title="其他实现代码"></a>其他实现代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int reverse(int x)</span><br><span class="line">&#123;</span><br><span class="line">    int max = 0x7fffffff, min = 0x80000000;//int的最大值最小值</span><br><span class="line">    long rs = 0;//用long类型判断溢出</span><br><span class="line">    for(;x;rs = rs*10+x%10,x/=10);//逆序，正负通吃，不用单独考虑负值</span><br><span class="line">    return rs&gt;max||rs&lt;min?0:rs;//超了最大值低于最小值就返回0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>执行用时 :4 ms, 在所有 c 提交中击败了80.32%的用户<br>内存消耗 :6.8 MB, 在所有 c 提交中击败了76.46%的用户</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;整数反转&quot;&gt;&lt;a href=&quot;#整数反转&quot; class=&quot;headerlink&quot; title=&quot;整数反转&quot;&gt;&lt;/a&gt;整数反转&lt;/h3&gt;&lt;p&gt;给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;/p&gt;
&lt;figure 
      
    
    </summary>
    
    
      <category term="Leetcode字符串" scheme="http://yoursite.com/categories/Leetcode%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="循环" scheme="http://yoursite.com/categories/Leetcode%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%BE%AA%E7%8E%AF/"/>
    
      <category term="中等" scheme="http://yoursite.com/categories/Leetcode%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%BE%AA%E7%8E%AF/%E4%B8%AD%E7%AD%89/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="简单" scheme="http://yoursite.com/tags/%E7%AE%80%E5%8D%95/"/>
    
      <category term="字符串" scheme="http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="字符串的操作" scheme="http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>无重复字符的最长字串</title>
    <link href="http://yoursite.com/2019/11/11/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%97%E4%B8%B2/"/>
    <id>http://yoursite.com/2019/11/11/无重复字符的最长字串/</id>
    <published>2019-11-11T14:24:08.210Z</published>
    <updated>2019-11-11T14:24:08.213Z</updated>
    
    <content type="html"><![CDATA[<h3 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a>无重复字符的最长子串</h3><p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure><p>示例 3:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line"></span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-substring-without-repeating-characters</a></p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>使用滑动窗口，如果字符串为空，或只有1个，则返回0或1，初始窗口<code>start、end</code>都指向第一个字符，len为1，<code>maxLen</code>为1。每次检查end之后的字符是否在<code>start-end</code>之间有重复。<br>如果有，则把<code>start</code>移到找到的位置之后（因为这个字符的存在性由新加入字符表达） 无论找到没有，<code>end</code>都向后移动，直至结束。 每次移动后，重新计算长度<code>len=end-start+1</code>； 如果<code>maxLen&lt; len</code>，则<code>maxLne = len</code></p><h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int lengthOfLongestSubstring(char * s)&#123;</span><br><span class="line">    int start = 0, end = 0, maxLen = 0,len = 0,i;</span><br><span class="line">    len = strlen(s);</span><br><span class="line">    if(len ==0 || len == 1)</span><br><span class="line">    &#123;</span><br><span class="line">        return len;</span><br><span class="line">    &#125;</span><br><span class="line">    while(s[end+1] != 0) //每次取下一位，判断是否为空</span><br><span class="line">    &#123;</span><br><span class="line">        for(i = start; i &lt;= end; ++i)//判断是否与前面的重复</span><br><span class="line">        &#123;</span><br><span class="line">            if(s[end+1] == s[i])</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        if(i &lt;= end)//与前面的重复了才会执行，移动到第一个与之重复的位置</span><br><span class="line">        &#123;</span><br><span class="line">            start = i+1;</span><br><span class="line">        &#125;</span><br><span class="line">        end++;//窗口扩大</span><br><span class="line">        len = end - start +1; //计算当前长度</span><br><span class="line">        if(maxLen &lt; len)</span><br><span class="line">        &#123;</span><br><span class="line">            maxLen = len;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>执行用时 :12 ms, 在所有 c 提交中击败了53.58%的用户<br>内存消耗 :7.1 MB, 在所有 c 提交中击败了82.26%的用户</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;无重复字符的最长子串&quot;&gt;&lt;a href=&quot;#无重复字符的最长子串&quot; class=&quot;headerlink&quot; title=&quot;无重复字符的最长子串&quot;&gt;&lt;/a&gt;无重复字符的最长子串&lt;/h3&gt;&lt;p&gt;给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="Leetcode字符串" scheme="http://yoursite.com/categories/Leetcode%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="滑动窗口" scheme="http://yoursite.com/categories/Leetcode%E5%AD%97%E7%AC%A6%E4%B8%B2/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
      <category term="中等" scheme="http://yoursite.com/categories/Leetcode%E5%AD%97%E7%AC%A6%E4%B8%B2/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/%E4%B8%AD%E7%AD%89/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="中等" scheme="http://yoursite.com/tags/%E4%B8%AD%E7%AD%89/"/>
    
      <category term="字符串" scheme="http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="字符串的操作" scheme="http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>两数之和</title>
    <link href="http://yoursite.com/2019/11/11/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://yoursite.com/2019/11/11/两数之和/</id>
    <published>2019-11-11T13:26:31.661Z</published>
    <updated>2019-11-11T13:26:31.663Z</updated>
    
    <content type="html"><![CDATA[<h3 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h3><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [2, 7, 11, 15], target = 9</span><br><span class="line"></span><br><span class="line">因为 nums[0] + nums[1] = 2 + 7 = 9</span><br><span class="line">所以返回 [0, 1]</span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/two-sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/two-sum</a></p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>遍历整个数组，两两相加，直到找到答案，构建动态链表存储结果并返回，否则返回结果为空。</p><h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">int* twoSum(int* nums, int numsSize, int target, int* returnSize)&#123;</span><br><span class="line">    int i,j;</span><br><span class="line">    int* result = NULL;</span><br><span class="line">    if(nums == NULL) //判断传来的数组是否为空</span><br><span class="line">    &#123;</span><br><span class="line">        //*returnSize = 0;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    for(i = 0; i &lt; numsSize-1; ++i) //遍历整个数组，两两相加</span><br><span class="line">    &#123;</span><br><span class="line">        for(j = i+1; j &lt; numsSize; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            if(nums[i] + nums[j] == target)</span><br><span class="line">            &#123;</span><br><span class="line">                result = (int*) malloc (sizeof(int)*2);</span><br><span class="line">                result[0] = i;</span><br><span class="line">                result[1] = j;</span><br><span class="line">                *returnSize = 2;</span><br><span class="line">                return result; //如果找到 就将结果返回</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result; //如果没有找到 就返回空的result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>执行用时 :160 ms, 在所有 c 提交中击败了87.44%的用户<br>内存消耗 :7.6 MB, 在所有 c 提交中击败了53.48%的用户</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;两数之和&quot;&gt;&lt;a href=&quot;#两数之和&quot; class=&quot;headerlink&quot; title=&quot;两数之和&quot;&gt;&lt;/a&gt;两数之和&lt;/h3&gt;&lt;p&gt;给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。
      
    
    </summary>
    
    
      <category term="Leetcode数组" scheme="http://yoursite.com/categories/Leetcode%E6%95%B0%E7%BB%84/"/>
    
      <category term="遍历" scheme="http://yoursite.com/categories/Leetcode%E6%95%B0%E7%BB%84/%E9%81%8D%E5%8E%86/"/>
    
      <category term="简单" scheme="http://yoursite.com/categories/Leetcode%E6%95%B0%E7%BB%84/%E9%81%8D%E5%8E%86/%E7%AE%80%E5%8D%95/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="遍历" scheme="http://yoursite.com/tags/%E9%81%8D%E5%8E%86/"/>
    
      <category term="简单" scheme="http://yoursite.com/tags/%E7%AE%80%E5%8D%95/"/>
    
  </entry>
  
  <entry>
    <title>先序遍历构建二叉树</title>
    <link href="http://yoursite.com/2019/11/10/%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9E%84%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2019/11/10/先序遍历构建二叉树/</id>
    <published>2019-11-10T13:57:44.784Z</published>
    <updated>2019-11-10T13:57:44.785Z</updated>
    
    <content type="html"><![CDATA[<h3 id="先序遍历构造二叉树"><a href="#先序遍历构造二叉树" class="headerlink" title="先序遍历构造二叉树"></a>先序遍历构造二叉树</h3><p>返回与给定先序遍历 preorder 相匹配的二叉搜索树（binary search tree）的根结点。</p><p>(回想一下，二叉搜索树是二叉树的一种，其每个节点都满足以下规则，对于<code>node.left</code> 的任何后代，值总 <code>&lt; node.val</code>，而 <code>node.right</code> 的任何后代，值总<code>&gt; node.val</code>。此外，先序遍历首先显示节点的值，然后遍历 <code>node.left</code>，接着遍历 <code>node.right</code>。）</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[8,5,1,7,10,12]</span><br><span class="line">输出：[8,5,10,1,7,null,12]</span><br></pre></td></tr></table></figure><p><img src="http://tva1.sinaimg.cn/large/007X8olVly1g8ta7z9iwqj30ge0aqdgf.jpg" alt="示意图"></p><p>提示：<br><code>1 &lt;= preorder.length &lt;= 100</code><br>先序<code>preorder</code> 中的值是不同的。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/construct-binary-search-tree-from-preorder-traversal" target="_blank" rel="noopener">https://leetcode-cn.com/problems/construct-binary-search-tree-from-preorder-traversal</a></p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>构建二叉树，如果根节点为空，则根结点的值为要插入的值，并将其左右子树置为空，如果要插入的结点值比根节点值大，则在右子树中调用插入结点的方法，反之在左子树中调用这个插入结点的函数。<br>使用<code>for</code>循环，依次传递要插入的结点。利用循环与递归实现先序遍历构造二叉树</p><h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     struct TreeNode *left;</span><br><span class="line"> *     struct TreeNode *right;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">struct TreeNode* add(struct TreeNode* root, int num)</span><br><span class="line">&#123;</span><br><span class="line">    if(root == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        root = (struct TreeNode*)malloc(sizeof(struct TreeNode));</span><br><span class="line">        root-&gt;val = num;</span><br><span class="line">        root-&gt;left = NULL;</span><br><span class="line">        root-&gt;right = NULL;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    if(root-&gt;val &gt; num)</span><br><span class="line">    &#123;</span><br><span class="line">        root-&gt;left = add(root-&gt;left,num);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        root-&gt;right = add(root-&gt;right,num);   </span><br><span class="line">    &#125; </span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct TreeNode* bstFromPreorder(int* preorder, int preorderSize)&#123;</span><br><span class="line">    struct TreeNode* root = NULL;</span><br><span class="line">    for(int i = 0; i &lt; preorderSize; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        root = add(root,preorder[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>执行用时 :0 ms, 在所有 c 提交中击败了100.00%的用户<br>内存消耗 :9.5 MB, 在所有 c 提交中击败了9.09%的用户</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;先序遍历构造二叉树&quot;&gt;&lt;a href=&quot;#先序遍历构造二叉树&quot; class=&quot;headerlink&quot; title=&quot;先序遍历构造二叉树&quot;&gt;&lt;/a&gt;先序遍历构造二叉树&lt;/h3&gt;&lt;p&gt;返回与给定先序遍历 preorder 相匹配的二叉搜索树（binary search
      
    
    </summary>
    
    
      <category term="Leetcode二叉树" scheme="http://yoursite.com/categories/Leetcode%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="递归" scheme="http://yoursite.com/categories/Leetcode%E4%BA%8C%E5%8F%89%E6%A0%91/%E9%80%92%E5%BD%92/"/>
    
      <category term="简单" scheme="http://yoursite.com/categories/Leetcode%E4%BA%8C%E5%8F%89%E6%A0%91/%E9%80%92%E5%BD%92/%E7%AE%80%E5%8D%95/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="二叉树" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="递归" scheme="http://yoursite.com/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="简单" scheme="http://yoursite.com/tags/%E7%AE%80%E5%8D%95/"/>
    
      <category term="构建二叉树" scheme="http://yoursite.com/tags/%E6%9E%84%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>如何上传文件夹下多个文件</title>
    <link href="http://yoursite.com/2019/11/09/%E5%A6%82%E4%BD%95%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B%E5%A4%9A%E4%B8%AA%E6%96%87%E4%BB%B6/"/>
    <id>http://yoursite.com/2019/11/09/如何上传文件夹下多个文件/</id>
    <published>2019-11-09T14:21:16.918Z</published>
    <updated>2019-11-09T14:21:16.919Z</updated>
    
    <content type="html"><![CDATA[<h3 id="如何上传文件夹下多个文件"><a href="#如何上传文件夹下多个文件" class="headerlink" title="如何上传文件夹下多个文件"></a>如何上传文件夹下多个文件</h3><ol><li>进入git项目的本地文件夹，将自己的项目复制到这个git 文件夹，查看状态，提交所有的新文件</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git status </span><br><span class="line">git add -A</span><br><span class="line">git commit -a -m&quot;first commit&quot;</span><br></pre></td></tr></table></figure><ol start="2"><li>上传更新到git 版本库<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure></li></ol><p>注：<code>git add</code>上传本地项目所有变化的命令三种有<code>git add -A</code>、<code>git add -u</code>、<code>git add</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add -A  提交所有变化</span><br><span class="line">git add -u  提交被修改(modified)和被删除(deleted)文件，不包括新文件(new)</span><br><span class="line">git add .  提交新文件(new)和被修改(modified)文件，不包括被删除(deleted)文件</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;如何上传文件夹下多个文件&quot;&gt;&lt;a href=&quot;#如何上传文件夹下多个文件&quot; class=&quot;headerlink&quot; title=&quot;如何上传文件夹下多个文件&quot;&gt;&lt;/a&gt;如何上传文件夹下多个文件&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;进入git项目的本地文件夹，将自己的项目复制到这
      
    
    </summary>
    
    
      <category term="Git" scheme="http://yoursite.com/categories/Git/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
      <category term="小技巧" scheme="http://yoursite.com/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    
      <category term="上传" scheme="http://yoursite.com/tags/%E4%B8%8A%E4%BC%A0/"/>
    
  </entry>
  
  <entry>
    <title>平衡二叉树</title>
    <link href="http://yoursite.com/2019/11/09/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2019/11/09/平衡二叉树/</id>
    <published>2019-11-09T14:11:07.573Z</published>
    <updated>2019-11-09T14:11:07.656Z</updated>
    
    <content type="html"><![CDATA[<h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p><p>本题中，一棵高度平衡二叉树定义为：</p><blockquote><p>一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。</p></blockquote><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">给定二叉树 [3,9,20,null,null,15,7]</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br></pre></td></tr></table></figure><p>返回 true 。</p><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">给定二叉树 [1,2,2,3,3,null,null,4,4]</span><br><span class="line"></span><br><span class="line">       1</span><br><span class="line">      / \</span><br><span class="line">     2   2</span><br><span class="line">    / \</span><br><span class="line">   3   3</span><br><span class="line">  / \</span><br><span class="line"> 4   4</span><br></pre></td></tr></table></figure><p>返回 false 。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/balanced-binary-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/balanced-binary-tree</a></p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>使用递归完成，分别获取左子树与右子树的高度，求左子树减去右子树的绝对值，如果大于一则一直返回 -1 ， -1表示这棵树已经失去平衡了。</p><h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int balance(struct TreeNode* root)&#123;</span><br><span class="line">    if(root == NULL)</span><br><span class="line">        return 0;</span><br><span class="line">    int left = balance(root-&gt;left); //left表示左子树的高度</span><br><span class="line">    if(left == -1)</span><br><span class="line">        return -1;</span><br><span class="line">    int right = balance(root-&gt;right);// right表示右子树的高度</span><br><span class="line">    if(right == -1)</span><br><span class="line">        return -1;</span><br><span class="line">    if(abs(left - right) &gt; 1) //-1 用来表示已经产生不平衡了</span><br><span class="line">        return -1;</span><br><span class="line">    return (left &gt; right ? left : right) + 1;</span><br><span class="line">&#125;</span><br><span class="line">bool isBalanced(struct TreeNode* root) &#123;</span><br><span class="line">    return balance(root) != -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>执行用时 :16 ms, 在所有 c 提交中击败了51.56%的用户<br>内存消耗 :10.2 MB, 在所有 c 提交中击败了100.00%的用户</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;平衡二叉树&quot;&gt;&lt;a href=&quot;#平衡二叉树&quot; class=&quot;headerlink&quot; title=&quot;平衡二叉树&quot;&gt;&lt;/a&gt;平衡二叉树&lt;/h3&gt;&lt;p&gt;给定一个二叉树，判断它是否是高度平衡的二叉树。&lt;/p&gt;
&lt;p&gt;本题中，一棵高度平衡二叉树定义为：&lt;/p&gt;
&lt;bloc
      
    
    </summary>
    
    
      <category term="Leetcode二叉树" scheme="http://yoursite.com/categories/Leetcode%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="递归" scheme="http://yoursite.com/categories/Leetcode%E4%BA%8C%E5%8F%89%E6%A0%91/%E9%80%92%E5%BD%92/"/>
    
      <category term="简单" scheme="http://yoursite.com/categories/Leetcode%E4%BA%8C%E5%8F%89%E6%A0%91/%E9%80%92%E5%BD%92/%E7%AE%80%E5%8D%95/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="二叉树" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="递归" scheme="http://yoursite.com/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="简单" scheme="http://yoursite.com/tags/%E7%AE%80%E5%8D%95/"/>
    
      <category term="平衡二叉树" scheme="http://yoursite.com/tags/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的中序遍历</title>
    <link href="http://yoursite.com/2019/11/08/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>http://yoursite.com/2019/11/08/二叉树的中序遍历/</id>
    <published>2019-11-08T13:56:03.979Z</published>
    <updated>2019-11-08T13:56:03.981Z</updated>
    
    <content type="html"><![CDATA[<h3 id="二叉树的中序遍历"><a href="#二叉树的中序遍历" class="headerlink" title="二叉树的中序遍历"></a>二叉树的中序遍历</h3><p>给定一个二叉树，返回它的中序 遍历。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">输出: [1,3,2]</span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-inorder-traversal</a></p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>利用递归，根据中序遍历的规则，先访问左子树，再访问根节点，最后是右子树。创建一个动态链表用来记录遍历的节点。注意调用函数时传的参数。</p><h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void inorderTravel(struct TreeNode* root,int *result,int *rSize)</span><br><span class="line">&#123;</span><br><span class="line">    if(!root)</span><br><span class="line">        return ;</span><br><span class="line">    inorderTravel(root-&gt;left, result, rSize);</span><br><span class="line">    result[*rSize] = root-&gt;val;</span><br><span class="line">    ++(*rSize);</span><br><span class="line">    inorderTravel(root-&gt;right, result, rSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int* inorderTraversal(struct TreeNode* root, int* returnSize)&#123;</span><br><span class="line">    int *result = (int*) malloc (sizeof(int)*1000);</span><br><span class="line">    int rSize = 0;</span><br><span class="line">    inorderTravel(root, result, &amp;rSize);</span><br><span class="line">    *returnSize = rSize;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>执行用时 :4 ms, 在所有 c 提交中击败了71.25%的用户<br>内存消耗 :7.4 MB, 在所有 c 提交中击败了90.51%的用户</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;二叉树的中序遍历&quot;&gt;&lt;a href=&quot;#二叉树的中序遍历&quot; class=&quot;headerlink&quot; title=&quot;二叉树的中序遍历&quot;&gt;&lt;/a&gt;二叉树的中序遍历&lt;/h3&gt;&lt;p&gt;给定一个二叉树，返回它的中序 遍历。&lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;figure clas
      
    
    </summary>
    
    
      <category term="Leetcode二叉树" scheme="http://yoursite.com/categories/Leetcode%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="递归" scheme="http://yoursite.com/categories/Leetcode%E4%BA%8C%E5%8F%89%E6%A0%91/%E9%80%92%E5%BD%92/"/>
    
      <category term="中等" scheme="http://yoursite.com/categories/Leetcode%E4%BA%8C%E5%8F%89%E6%A0%91/%E9%80%92%E5%BD%92/%E4%B8%AD%E7%AD%89/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="中等" scheme="http://yoursite.com/tags/%E4%B8%AD%E7%AD%89/"/>
    
      <category term="二叉树" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="递归" scheme="http://yoursite.com/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
</feed>
