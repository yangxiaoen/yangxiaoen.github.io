<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>滑动窗口最大值</title>
    <url>/2019/11/03/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
    <content><![CDATA[<h3 id="滑动窗口最大值"><a href="#滑动窗口最大值" class="headerlink" title="滑动窗口最大值"></a>滑动窗口最大值</h3><p>给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p>
<p>返回滑动窗口中的最大值。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3</span><br><span class="line">输出: [3,3,5,5,6,7] </span><br><span class="line">解释: </span><br><span class="line"></span><br><span class="line">  滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/sliding-window-maximum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sliding-window-maximum</a></p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>有两种解题方法</p>
<ol>
<li>一种是每k个元素进行比较，创建一个链表将最大值输出</li>
<li>第二种是创建一个双端链表，将元素从队尾入队，如果后一个节点元素数值比前一个大则前一个数值移除，如果比前一个结点元素数值小，则入队。这样就能保证队列的第一个元素为当前k个数值中最大的<br><img src="http://tva1.sinaimg.cn/large/007X8olVly1g8l7raet5lj30lp08y0tt.jpg" alt="henbang"></li>
</ol>
<h4 id="第一种想法完整代码如下"><a href="#第一种想法完整代码如下" class="headerlink" title="第一种想法完整代码如下"></a>第一种想法完整代码如下</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Note: The returned array must be malloced, assume caller calls free().</span><br><span class="line"> */</span><br><span class="line">/*</span><br><span class="line">    maxInk()用于比较k个数值中最大值</span><br><span class="line">*/</span><br><span class="line">int maxInk(int *nums,int k)</span><br><span class="line">&#123;</span><br><span class="line">    int max=nums[0];</span><br><span class="line">    int i;</span><br><span class="line">    for(i = 0; i &lt; k; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        if(nums[i] &gt; max)</span><br><span class="line">            max = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int* maxSlidingWindow(int* nums, int numsSize, int k, int* returnSize)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    int end = numsSize - k;</span><br><span class="line">    int rsize = numsSize - k + 1;</span><br><span class="line">    if(numsSize == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        * returnSize = 0;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    * returnSize = rsize;</span><br><span class="line">    int *r = (int *)malloc(sizeof(int)*rsize);</span><br><span class="line">    memset(r,0,sizeof(int)*rsize);</span><br><span class="line">    </span><br><span class="line">    for(i = 0; i&lt;= end; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        r[i] = maxInk(nums+i,k);</span><br><span class="line">    &#125;</span><br><span class="line">    return r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>执行用时 :144 ms, 在所有 c 提交中击败了40.05% 的用户<br>内存消耗 :15.9 MB, 在所有 c 提交中击败了18.18%的用户</p>
</blockquote>
<h4 id="第二种想法完整代码如下"><a href="#第二种想法完整代码如下" class="headerlink" title="第二种想法完整代码如下"></a>第二种想法完整代码如下</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">	int *qdata;</span><br><span class="line">	int head;</span><br><span class="line">	int tail;</span><br><span class="line">	int qlen;</span><br><span class="line">&#125;Queue;</span><br><span class="line"></span><br><span class="line">void queue_init(Queue* q, int n)</span><br><span class="line">&#123;</span><br><span class="line">	if(n&gt;=0)</span><br><span class="line">	&#123;</span><br><span class="line">		q-&gt;qlen = n+1;</span><br><span class="line">		q-&gt;qdata = (int *)malloc(sizeof(int) *q-&gt;qlen);</span><br><span class="line">		q-&gt;head = 0;</span><br><span class="line">		q-&gt;tail = 0;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void queue_destroy(Queue *q)</span><br><span class="line">&#123;</span><br><span class="line">	free(q-&gt;qdata);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int queue_is_full(Queue* q)</span><br><span class="line">&#123;</span><br><span class="line">	if((q-&gt;tail+1)%q-&gt;qlen == q-&gt;head) return 1;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int queue_is_empty(Queue*q )</span><br><span class="line">&#123;</span><br><span class="line">	return q-&gt;head == q-&gt;tail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void queue_add_tail(Queue *q, int e)</span><br><span class="line">&#123;</span><br><span class="line">	if(!queue_is_full(q))</span><br><span class="line">	&#123;</span><br><span class="line">		q-&gt;qdata[q-&gt;tail] = e;</span><br><span class="line">		q-&gt;tail = (q-&gt;tail+1)%q-&gt;qlen;</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;%d not add, queue is full\n&quot;, e);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int queue_pull_head(Queue *q)</span><br><span class="line">&#123;</span><br><span class="line">	if(!queue_is_empty(q))</span><br><span class="line">	&#123;</span><br><span class="line">		int r = q-&gt;qdata[q-&gt;head];</span><br><span class="line">		q-&gt;head = (q-&gt;head+1)%q-&gt;qlen;</span><br><span class="line">		return r;</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;not pull, queue is empty\n&quot;);</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int queue_peek_head(Queue *q)</span><br><span class="line">&#123;</span><br><span class="line">	if(!queue_is_empty(q))</span><br><span class="line">		return q-&gt;qdata[q-&gt;head];</span><br><span class="line">	return -1;</span><br><span class="line">&#125;</span><br><span class="line">int queue_pull_tail(Queue *q)</span><br><span class="line">&#123;</span><br><span class="line">    int r = q-&gt;qdata[(q-&gt;tail-1+q-&gt;qlen)%q-&gt;qlen];</span><br><span class="line">    if(!queue_is_empty(q))</span><br><span class="line">    &#123;</span><br><span class="line">        q-&gt;tail = (q-&gt;tail-1+q-&gt;qlen)%q-&gt;qlen;</span><br><span class="line">    &#125;</span><br><span class="line">    return r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int queue_peek_tail(Queue *q)</span><br><span class="line">&#123;</span><br><span class="line">    if(!queue_is_empty(q))</span><br><span class="line">    &#123;</span><br><span class="line">        return q-&gt;qdata[(q-&gt;tail-1+q-&gt;qlen)%q-&gt;qlen];</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line">void queue_print(Queue *q)</span><br><span class="line">&#123;</span><br><span class="line">	int i;</span><br><span class="line">    printf(&quot;in queue: &quot;);</span><br><span class="line">	for(i = q-&gt;head; i != q-&gt;tail; i= (i+1)%q-&gt;qlen)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;%d &quot;,q-&gt;qdata[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void queue_reflact(Queue *q, int *nums)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    printf(&quot;in queue: &quot;);</span><br><span class="line">	for(i = q-&gt;head; i != q-&gt;tail; i= (i+1)%q-&gt;qlen)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;%d &quot;,nums[q-&gt;qdata[i]]);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void pr(int* nums, int numsSize)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    printf(&quot;result: &quot;);</span><br><span class="line">    for(i=0; i&lt;numsSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%d &quot;,nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int* maxSlidingWindow(int* nums, int numsSize, int k, int* returnSize)&#123;</span><br><span class="line">    int i;</span><br><span class="line">    int j=0;</span><br><span class="line">    </span><br><span class="line">    int rsize = numsSize -k +1; </span><br><span class="line">    if(numsSize==0)</span><br><span class="line">    &#123;</span><br><span class="line">        *returnSize = 0;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue qnode;</span><br><span class="line">    Queue* q = &amp;qnode;</span><br><span class="line">    queue_init(q, k);</span><br><span class="line">    </span><br><span class="line">    *returnSize = rsize;</span><br><span class="line">    int *r = (int *)malloc(sizeof(int)*rsize);</span><br><span class="line">    *returnSize = rsize;</span><br><span class="line">    memset(r, 0, sizeof(int)*rsize);</span><br><span class="line">     </span><br><span class="line">    for(i=0; i&lt;numsSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(queue_is_empty(q))</span><br><span class="line">        &#123; </span><br><span class="line">            queue_add_tail(q, i);</span><br><span class="line">            goto juge;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        if(queue_peek_head(q)&lt;=i-k)</span><br><span class="line">        &#123;</span><br><span class="line">            queue_pull_head(q);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while(!queue_is_empty(q) &amp;&amp; nums[queue_peek_tail(q)] &lt; nums[i])</span><br><span class="line">        &#123;</span><br><span class="line">             queue_pull_tail(q);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        queue_add_tail(q, i);</span><br><span class="line"> </span><br><span class="line">        juge:if(i-k+1&gt;=0)&#123;</span><br><span class="line">            r[j++] = nums[queue_peek_head(q)];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行用时 :76 ms, 在所有 c 提交中击败了84.56% 的用户<br>内存消耗 :16.1 MB, 在所有 c 提交中击败了9.09%的用户</p>
</blockquote>
]]></content>
      <categories>
        <category>Leetcode队列</category>
        <category>困难</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>队列</tag>
        <tag>困难</tag>
      </tags>
  </entry>
  <entry>
    <title>每日温度</title>
    <url>/2019/11/02/%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/</url>
    <content><![CDATA[<h3 id="每日温度"><a href="#每日温度" class="headerlink" title="每日温度"></a>每日温度</h3><p>根据每日 气温 列表，请重新生成一个列表，对应位置的输入是你需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用?0 来代替。</p>
<p>例如，给定一个列表?<code>temperatures = [73, 74, 75, 71, 69, 72, 76, 73]</code>，你的输出应该是?<code>[1, 1, 4, 2, 1, 1, 0, 0]</code>。</p>
<p>提示：气温 列表长度的范围是?<code>[1, 30000]</code>。每个气温的值的均为华氏度，都是在?<code>[30, 100]?</code>范围内的整数。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/daily-temperatures" target="_blank" rel="noopener">https://leetcode-cn.com/problems/daily-temperatures</a></p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>创建一个栈，把第一天的温度放进栈内，第二天与之比较，如果比第一天温度高，则应该输出1，如果比第一天温度低，就把这个温度值也入栈，继续下一个数值进行比较，如果温度比第二天高，则对应的第二天输出的应该为1，第二天的温度值出栈，然后与第一天的进行比较，如果大则第一天的数值出栈，对应输出为2，否则继续下一个元素按照这种方法比较，直到最后一个比较完，栈内还有元素就依次出栈，每个元素对应的输出结果为0.<br><strong>实现过程</strong></p>
<ul>
<li>定义一个栈，并定义栈顶指针top</li>
<li>创建一个链表<code>res</code> 用来存储结果，定义一个 <code>temp</code>用来存储数组下标</li>
<li>核心代码如下<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(i = 0; i&lt; TSize; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    while(top != -1 &amp;&amp; T[i]&gt;T[stack[top]])</span><br><span class="line">    &#123;</span><br><span class="line">        temp = stack[top];</span><br><span class="line">        top--;//处理下标的距离</span><br><span class="line">        res[temp] = i - temp;</span><br><span class="line">    &#125;</span><br><span class="line">    ++top;//栈空了或者满足递减条件就入站</span><br><span class="line">    stack[top] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="完整代码如下"><a href="#完整代码如下" class="headerlink" title="完整代码如下"></a>完整代码如下</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Note: The returned array must be malloced, assume caller calls free().</span><br><span class="line"> */</span><br><span class="line">#define MAX 30000</span><br><span class="line"></span><br><span class="line">int* dailyTemperatures(int* T, int TSize, int* returnSize)&#123;</span><br><span class="line">    int stack[MAX] = &#123;0&#125;;</span><br><span class="line">    int top = -1,i = 0, temp = 0;</span><br><span class="line">    int* res =(int *)malloc(sizeof(int)*TSize);</span><br><span class="line">    memset(res,0,sizeof(int)*TSize);//初始化函数 给res中 sizeof(int)*Tsize个赋值为0</span><br><span class="line">    if(res == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        * returnSize = 0;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    for(i = 0; i&lt; TSize; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        while(top != -1 &amp;&amp; T[i]&gt;T[stack[top]])</span><br><span class="line">        &#123;</span><br><span class="line">            temp = stack[top];</span><br><span class="line">            top--;//处理下标的距离</span><br><span class="line">            res[temp] = i - temp;</span><br><span class="line">        &#125;</span><br><span class="line">        ++top;//栈空了或者满足递减条件就入站</span><br><span class="line">        stack[top] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    * returnSize = TSize;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<blockquote>
<p>执行用时 :232 ms, 在所有?c?提交中击败了53.11%的用户<br>内存消耗 :23.8 MB, 在所有?c?提交中击败了76.47%的用户</p>
</blockquote>
]]></content>
      <categories>
        <category>Leetcode数组</category>
        <category>中等</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>栈</tag>
        <tag>中等</tag>
      </tags>
  </entry>
  <entry>
    <title>有效的括号</title>
    <url>/2019/11/01/%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</url>
    <content><![CDATA[<h2 id="有效的括号"><a href="#有效的括号" class="headerlink" title="有效的括号"></a>有效的括号</h2><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;()&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;()[]&#123;&#125;&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<p>示例 3:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;(]&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<p>示例 4:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;([)]&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<p>示例 5:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;&#123;[]&#125;&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/valid-parentheses" target="_blank" rel="noopener">https://leetcode-cn.com/problems/valid-parentheses</a></p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul>
<li>获取要判断的字符串长度，如果字符串为空，返回true 否则返回false</li>
<li>创建一个栈 在字符串中找到 ‘(’ 或者 ‘{‘ 或者 ‘[‘的时候进栈，找到与之匹配的‘)’ 或者 ‘}’ 或者 ‘]’时候出栈 </li>
<li>如何查找是否匹配 写了一个函数 isTrue 用来判断是否匹配<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool isTrue(char a,char b)</span><br><span class="line">&#123;</span><br><span class="line">    if((a == &apos;(&apos; &amp;&amp; b == &apos;)&apos;) || (a == &apos;&#123;&apos; &amp;&amp; b == &apos;&#125;&apos;) ||(a == &apos;[&apos; &amp;&amp; b == &apos;]&apos;))</span><br><span class="line">        return true;</span><br><span class="line">    else </span><br><span class="line">        return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>遍历整个字符串，进行对应的出栈和进栈</li>
<li>如果遍历结束，栈为空则表示完全匹配，否则表示不匹配</li>
</ul>
<h4 id="对于这个题的完整代码如下"><a href="#对于这个题的完整代码如下" class="headerlink" title="对于这个题的完整代码如下"></a>对于这个题的完整代码如下</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool isTrue(char a,char b)</span><br><span class="line">&#123;</span><br><span class="line">    if((a == &apos;(&apos; &amp;&amp; b == &apos;)&apos;) || (a == &apos;&#123;&apos; &amp;&amp; b == &apos;&#125;&apos;) ||(a == &apos;[&apos; &amp;&amp; b == &apos;]&apos;))</span><br><span class="line">        return true;</span><br><span class="line">    else </span><br><span class="line">        return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool isValid(char * s)&#123;</span><br><span class="line">    int top = -1;</span><br><span class="line">    int len=strlen(s);</span><br><span class="line">    if(len == 0)</span><br><span class="line">        return true;</span><br><span class="line">    char str[len];</span><br><span class="line">    int i=0;</span><br><span class="line">    for(i=0; i&lt;len ;++i)</span><br><span class="line">    &#123;</span><br><span class="line">         if(top==-1 || !(isTrue(str[top],s[i])))</span><br><span class="line">        &#123;</span><br><span class="line">            ++top;</span><br><span class="line">            str[top] = s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        else if(isTrue(str[top],s[i]))</span><br><span class="line">        &#123;</span><br><span class="line">            --top;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(top == -1)</span><br><span class="line">        return true;</span><br><span class="line">    else</span><br><span class="line">        return false;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<blockquote>
<p>执行用时 :4 ms, 在所有 c 提交中击败了69.12%的用户<br>内存消耗 :6.9 MB, 在所有 c 提交中击败了73.49%的用户</p>
</blockquote>
]]></content>
      <categories>
        <category>Leetcode简单</category>
        <category>简单</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>Leetcode</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>有效的字母异位词</title>
    <url>/2019/11/01/%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/</url>
    <content><![CDATA[<h3 id="有效的字母异位词"><a href="#有效的字母异位词" class="headerlink" title="有效的字母异位词"></a>有效的字母异位词</h3><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p>
<p>示例?1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;rat&quot;, t = &quot;car&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<p>说明:<br>你可以假设字符串只包含小写字母。</p>
<p>进阶:<br>如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/valid-anagram" target="_blank" rel="noopener">https://leetcode-cn.com/problems/valid-anagram</a></p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>解决字符串的问题，英文字母一共才26个，我们可以创建两个数组a[],b[]，数组中的元素分别对应字母”a,b,c….z“，遍历数组 s 数组s中每个字符对应的数组元素a[i]++，同理遍历数组 t 数组t中每个字符对应的数组元素b[i]++,然后比较数组a[]与数组b[],如果数组一致则<code>return true</code> 否则<code>return false</code></p>
<p>提交的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool isAnagram(char * s, char * t)&#123;</span><br><span class="line">    int a[26]=&#123;0&#125;;</span><br><span class="line">    int b[26]=&#123;0&#125;;</span><br><span class="line">    int n;</span><br><span class="line">    int i;</span><br><span class="line">    for(i=0;i&lt;strlen(s);++i)&#123;</span><br><span class="line">        if(s[i]&gt;=97 &amp;&amp; s[i]&lt;=123)</span><br><span class="line">        &#123;</span><br><span class="line">            n=s[i]-97;</span><br><span class="line">            a[n]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(i=0 ;i&lt;strlen(t); ++i)&#123;</span><br><span class="line">        if(t[i]&gt;=97 &amp;&amp; t[i]&lt;=123)</span><br><span class="line">         &#123;</span><br><span class="line">            n=t[i]-97;</span><br><span class="line">            b[n]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(i=0;i&lt;26;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        if(a[i]!=b[i])</span><br><span class="line">            return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>执行用时：344 ms<br>仅仅至战胜了5.12%的c提交记录</p>
</blockquote>
<p><strong>加油！每天做点数据结构练习!</strong></p>
]]></content>
      <categories>
        <category>Leetcode字符串</category>
        <category>简单</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>Leetcode</tag>
        <tag>简单</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>如何搭建个人博客 使用Hexo（一）</title>
    <url>/2019/11/01/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%20%E4%BD%BF%E7%94%A8Hexo%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>今天跟大家分享一篇文章，教大家如何一步步使用 GitHub 搭建出自己专属的个人博客！弄个博客网站不是要有服务器，数据库，域名的嘛？没事，如果都没有，我们依然可以搭建一个博客。这里我拿Win10系统做演示，对于Mac和Linux系统 基本是一样的</p>
<h4 id="准备条件"><a href="#准备条件" class="headerlink" title="准备条件"></a>准备条件</h4><p>首先大家需要一个GitHub的账户，GitHub Pages 允许每个账户创建一个名为 {username}.github.io 的仓库，另外它还会自动为这个仓库分配一个 github.io 的二级域名，这就解决了域名的问题，当然如果想要自定义域名的话，也可以支持，我后续会跟大家说的。</p>
<p>所以大家先注册个GitHub账号，我们就正式开始吧！</p>
<h4 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h4><ul>
<li><p>去<a href="https://nodejs.org" target="_blank" rel="noopener">官网</a>安装Node.js </p>
</li>
<li><p><img src="http://tva1.sinaimg.cn/large/007X8olVly1g8glapfwbwj30oc0eugma.jpg" alt="很棒哈"></p>
</li>
<li><p>下载好后一路 <strong>next</strong> 就好</p>
</li>
</ul>
<h4 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h4><ul>
<li>新建一个文件夹，比如我这里建了  blog  文件  </li>
<li>我们来看一下 Node.js是否安装成功</li>
<li><img src="http://tva1.sinaimg.cn/large/007X8olVly1g8glapmae5j30bq057t8l.jpg" alt="很棒哈"></li>
</ul>
<ul>
<li><p>由于国内镜像源速度不是很好，我们先来安装个cnpm提高速度，以后下载什么东西都用cnpm</p>
</li>
<li><p>执行如下命令 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure></li>
<li><p>等待安装完成</p>
</li>
<li><p><img src="http://tva1.sinaimg.cn/large/007X8olVly1g8glappw47j30mm073jre.jpg" alt="很棒哈"></p>
</li>
<li><p>安装完成看一下他的版本</p>
</li>
<li><p><img src="http://tva1.sinaimg.cn/large/007X8olVly1g8glapve37j30n00act8y.jpg" alt="很棒哈"></p>
</li>
<li><p><strong>安装Hexo</strong> 执行如下命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cnpm install -g hexo-cli</span><br></pre></td></tr></table></figure></li>
<li><p><img src="http://tva1.sinaimg.cn/large/007X8olVly1g8glaq20hwj30nf0k90tv.jpg" alt="很棒哈"></p>
</li>
<li><p>使用如下命令检测是否安装成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></table></figure></li>
<li><p><img src="http://tva1.sinaimg.cn/large/007X8olVly1g8glaq8xrzj308l082wed.jpg" alt="很棒哈"></p>
</li>
<li><p>安装完毕之后，确保环境变量配置好，能正常使用 hexo 命令。</p>
</li>
<li><p>查看当前路径命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwd</span><br></pre></td></tr></table></figure></li>
<li><p>结果为 我的是存放在D盘blog的文件夹内<br><img src="http://tva1.sinaimg.cn/large/007X8olVly1g8glaqe6xej306v03egld.jpg" alt="很棒哈"></p>
</li>
<li><p>然后我们运行命令，这步是关键，主要是建立整个项目，这里我的文件夹名字是blog</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure></li>
<li><p>等待下载安装完成，结果如下<br><img src="http://tva1.sinaimg.cn/large/007X8olVly1g8glaqlqa8j30n90d2t99.jpg" alt="很棒哈"><br><img src="http://tva1.sinaimg.cn/large/007X8olVly1g8glaqrkauj30oi07jmxf.jpg" alt="很棒哈"></p>
</li>
</ul>
<h4 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h4><ul>
<li><p>首先我们调用  Hexo 的 generate 命令，将 Hexo 编译生成 HTML 代码，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure></li>
<li><p>可以看到输出结果里面包含了 js、css、font 等内容，并发现他们都处在了项目根目录下的 public 文件夹下面了。<br><img src="http://tva1.sinaimg.cn/large/007X8olVly1g8glaqvv6oj30eq0dtmx8.jpg" alt="很棒哈"><br><img src="http://tva1.sinaimg.cn/large/007X8olVly1g8glar00z8j30nj06v0su.jpg" alt="很棒哈"></p>
</li>
<li><p>然后我们利用 Hexo 提供的 serve 命令把博客在本地运行起来，命令如下：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<ul>
<li><p>运行结果如下<br><img src="http://tva1.sinaimg.cn/large/007X8olVly1g8glar4s35j30ei01h3ya.jpg" alt="很棒哈"></p>
</li>
<li><p>我们在本地 4000 端口上就可以查看博客站点了，如图所示：<br><img src="http://tva1.sinaimg.cn/large/007X8olVly1g8glarlqx0j31b00s0gyo.jpg" alt="很棒哈"></p>
</li>
<li><p>到这为止我们就已经搭建好 一个博客框架了</p>
</li>
<li><p>记住这三条很常用的命令</p>
<blockquote>
<p>hexo clean #用来清理缓存文件<br>hexo g      #生成文件<br>hexo  s     #运行本地服务器<br>hexo  d   #上传到服务器</p>
</blockquote>
</li>
</ul>
<h4 id="这次我们就先说到这"><a href="#这次我们就先说到这" class="headerlink" title="这次我们就先说到这"></a>这次我们就先说到这</h4><ul>
<li>下一次我再跟大家分享 如何美化我们的博客。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>K个一组翻转链表</title>
    <url>/2019/11/01/K%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="K个一组翻转链表"><a href="#K个一组翻转链表" class="headerlink" title="K个一组翻转链表"></a>K个一组翻转链表</h2><p>给你一个链表，每?k?个节点一组进行翻转，请你返回翻转后的链表。</p>
<p>k?是一个正整数，它的值小于或等于链表的长度。</p>
<p>如果节点总数不是?k?的整数倍，那么请将最后剩余的节点保持原有顺序。</p>
<p>示例 :</p>
<p>给定这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5</p>
<p>当?k?= 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5</p>
<p>当?k?= 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&gt;5</p>
<p>说明 :</p>
<p>你的算法只能使用常数的额外空间。<br>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-nodes-in-k-group</a></p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>我们可以创建三个指针<code>pre</code>  <code>cur</code>   <code>next</code><br><code>pre</code>  指针指向开始节点，<code>cue</code>指针指向<code>pre</code> 的下一个节点，<code>next</code>指针指向<code>cur</code>指针的下一个节点。<br>每次移动让<code>next = cur-&gt;next</code>节点 <code>cur-&gt;next = pre</code>让cur的指针指向pre ，pre移动到cur的位置，cur移动到next的位置，这样就实现了 链表的反转<br>代码实现如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct ListNode* Myreverse(struct ListNode *head)&#123;</span><br><span class="line">    struct ListNode* next = NULL;</span><br><span class="line">    struct ListNode *pre = NULL;</span><br><span class="line">    struct ListNode *cur = head;</span><br><span class="line">    while(cur != NULL)&#123;</span><br><span class="line">        next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    return pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="对于这个题的完整代码如下"><a href="#对于这个题的完整代码如下" class="headerlink" title="对于这个题的完整代码如下"></a>对于这个题的完整代码如下</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct ListNode* Myreverse(struct ListNode *head);</span><br><span class="line">struct ListNode* reverseKGroup(struct ListNode* head, int k)&#123;</span><br><span class="line">    struct ListNode *cur = head, *start = head, *next = NULL, *result = head;</span><br><span class="line">    struct ListNode *pre = (struct ListNode*)malloc(sizeof(struct ListNode));</span><br><span class="line">    int flag = 0;//是否第一次翻转</span><br><span class="line">    pre-&gt;next = head;</span><br><span class="line">    while(cur != NULL)&#123;</span><br><span class="line">        for(int i = 1;(i&lt;k)&amp;&amp;(cur != NULL); i++)&#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        flag++;</span><br><span class="line">        if(cur == NULL) break;</span><br><span class="line">        next = cur-&gt;next;//后继</span><br><span class="line">        cur-&gt;next = NULL;//切断链表进行翻转</span><br><span class="line">        pre-&gt;next = Myreverse(start);</span><br><span class="line">        if (flag == 1) result = pre-&gt;next;</span><br><span class="line">        pre = start;</span><br><span class="line">        start-&gt;next = next;</span><br><span class="line">        cur = next;</span><br><span class="line">        start = next;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct ListNode* Myreverse(struct ListNode *head)&#123;</span><br><span class="line">    struct ListNode* next = NULL;</span><br><span class="line">    struct ListNode *pre = NULL;</span><br><span class="line">    struct ListNode *cur = head;</span><br><span class="line">    while(cur != NULL)&#123;</span><br><span class="line">        next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    return pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>执行用时：12 ms</p>
</blockquote>
]]></content>
      <categories>
        <category>Leetcode链表</category>
        <category>困难</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>困难</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/11/01/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>我的第一篇博客文章</title>
    <url>/2019/10/27/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h2 id="内容"><a href="#内容" class="headerlink" title=" 内容"></a> 内容</h2><h2 id="是否支持markdown"><a href="#是否支持markdown" class="headerlink" title="是否支持markdown"></a>是否支持markdown</h2><hr>
]]></content>
  </entry>
</search>
